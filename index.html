<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Code Rivals - C++ Challenge</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
<script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
<style>
    /* General Body and Font Styles */
    body {
        margin: 0;
        padding: 0;
        background: radial-gradient(circle at center, #001f3f, #000);
        font-family: 'Inter', sans-serif; /* General text font */
        color: #00ccff;
        display: flex;
        flex-direction: column;
        align-items: center;
        min-height: 100vh;
        width: 100vw;
        overflow-x: hidden; /* Prevent horizontal scroll */
        overflow-y: auto; /* Allow vertical scroll for content */
    }

    h1, h2, h3 {
        font-family: 'Orbitron', sans-serif; /* Keep Orbitron for titles */
        text-shadow: 0 0 10px #00ccff;
        color: #00ccff;
    }

    h1 {
        margin: 20px 0 10px;
        font-size: 32px;
    }

    /* Shared Primary Button Style */
    .primary-btn {
        padding: 8px 16px;
        background-color: #001f3f;
        border: 2px solid #00ccff;
        color: #00ccff;
        font-weight: bold;
        cursor: pointer;
        box-shadow: 0 0 10px #00ccff;
        border-radius: 8px;
        transition: transform 0.2s, box-shadow 0.2s, background-color 0.2s;
    }

    .primary-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 0 15px #00ff00;
        background-color: #003f6f; /* Slightly darker on hover */
    }

    .primary-btn:disabled {
        cursor: not-allowed;
        opacity: 0.5;
        background-color: #555;
        border-color: #888;
        box-shadow: none;
    }

    /* Logout Button */
    #logoutBtn {
        position: absolute;
        top: 10px;
        right: 10px;
        background-color: #a00000; /* Red color for logout */
        border-color: #ff0000;
        color: #fff;
        box-shadow: 0 0 10px #ff0000;
        z-index: 10;
        display: none; /* Hidden by default */
    }
    #logoutBtn:hover {
        background-color: #cc0000;
        box-shadow: 0 0 15px #ff6666;
    }

    #welcomeMessage {
        color: #fff;
        font-size: 18px;
        margin-top: 10px;
        display: none;
        text-align: center;
        margin-bottom: 20px;
    }

    /* Authentication Container */
    #authContainer {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        background-color: rgba(0,0,50,0.9);
        border: 2px solid #00ccff;
        border-radius: 20px;
        padding: 30px;
        width: 90%;
        max-width: 400px;
        text-align: center;
        box-shadow: 0 0 25px #00ccff;
        margin-top: 50px;
    }

    #authContainer h2 {
        margin-top: 0;
        margin-bottom: 25px;
    }

    #authContainer input[type="text"],
    #authContainer input[type="password"] {
        width: calc(100% - 20px);
        padding: 12px;
        margin-bottom: 15px;
        background-color: black;
        color: #00ccff;
        border: 1px solid #00ccff;
        border-radius: 5px;
        font-size: 16px;
        box-sizing: border-box;
    }

    #authContainer button {
        width: 100%;
        padding: 12px;
        font-size: 18px;
        margin-bottom: 10px;
    }

    #authSwitch {
        color: #00ccff;
        text-decoration: underline;
        cursor: pointer;
        font-size: 14px;
        margin-top: 15px;
        transition: color 0.2s;
    }
    #authSwitch:hover {
        color: #00ff00;
    }

    /* Game Mode Selection */
    #gameModeSelection, #rankedGameModeSelection { /* Added #rankedGameModeSelection */
        display: none; /* Hidden by default, shown after selecting a mode from main dashboard */
        flex-direction: column;
        align-items: center;
        background-color: rgba(0,0,50,0.9); /* Keep background for the container */
        border: 2px solid #00ccff;
        border-radius: 20px;
        padding: 20px;
        width: 90%;
        max-width: 600px;
        text-align: center;
        box-shadow: 0 0 20px #00ccff;
        margin-top: 50px;
        gap: 20px;
    }

    .game-mode-box {
        width: 100%;
        background-color: rgba(0, 0, 50, 0.8); /* Slightly transparent background for the box itself */
        border: 2px solid #00ccff;
        border-radius: 15px; /* Rounded corners for the box */
        padding: 25px; /* Increased padding for bigger buttons */
        cursor: pointer;
        transition: transform 0.2s, box-shadow 0.2s, background-color 0.2s;
        box-shadow: 0 0 15px #00ccff; /* Initial glow */
        text-align: center; /* Center text within the box */
    }

    .game-mode-box:hover {
        transform: translateY(-5px);
        box-shadow: 0 0 30px #00ff00; /* More intense glow on hover */
        background-color: rgba(0, 31, 63, 0.9); /* Slightly darker on hover */
    }

    .game-mode-box h3 {
        margin-top: 0;
        margin-bottom: 10px; /* Space between title and description */
        font-size: 24px; /* Larger title */
        text-shadow: 0 0 10px #00ccff;
    }

    .game-mode-box p {
        font-size: 16px; /* Larger description */
        color: #e0f2f7; /* Lighter color for readability */
        margin: 0;
    }

    /* Main Lobby Dashboard - Adjusted for full screen */
    #mainLobbyDashboard {
        /* Removed position: relative; as profile icon is now global */
        display: none; /* Hidden by default, shown after login */
        flex-direction: row; /* Default to row for wider screens */
        gap: 20px;
        width: 98%; /* Increased width to take more space */
        /* Removed max-width to allow it to expand more */
        justify-content: center;
        align-items: stretch;
        flex-grow: 1;
        min-height: 80vh;
        flex-wrap: wrap; /* Allow wrapping on smaller screens */
        margin-top: 20px;
        margin-bottom: 20px; /* Add some bottom margin */
    }

    .main-panel {
        background-color: rgba(0,0,50,0.9);
        border: 2px solid #00ccff;
        border-radius: 20px;
        box-shadow: 0 0 20px #00ccff;
        padding: 20px;
        display: flex;
        flex-direction: column;
        align-items: center;
        text-align: center;
        box-sizing: border-box;
        /* Ensure panels can grow and shrink */
        min-height: 300px; /* Ensure a minimum height for panels */
    }

    .left-panel-modes {
        flex: 1; /* Allow it to grow, but with a smaller base */
        min-width: 200px; /* Minimum width to prevent squishing */
        max-width: 250px; /* Keep it relatively narrow */
        gap: 15px;
        display: flex;
        flex-direction: column;
        justify-content: flex-start;
    }

    /* Make buttons inside left-panel-modes bigger */
    .left-panel-modes .primary-btn {
        padding: 15px 25px; /* Increased padding */
        font-size: 20px; /* Increased font size */
    }

    .center-panel-leaderboard {
        flex: 3; /* Increased flex-grow to take significantly more space */
        min-width: 450px; /* Increased minimum width for leaderboard */
    }

    .right-panel-updates {
        flex: 1.5; /* Takes more space than left, less than center */
        min-width: 300px; /* Minimum width for updates */
        max-width: 350px; /* Keep it relatively narrow */
        gap: 20px;
        display: flex;
        flex-direction: column;
        justify-content: flex-start;
    }

    .right-panel-updates ul {
        list-style: none;
        padding: 0;
        margin: 0;
        text-align: left;
        font-size: 14px;
        color: #e0f2f7;
        flex-grow: 1; /* Allow the list to take available space */
        overflow-y: auto; /* Add scroll if content overflows */
    }

    .right-panel-updates ul li {
        margin-bottom: 5px;
    }

    /* Profile Icon */
    #profileIcon {
        position: absolute; /* Position relative to the viewport now */
        top: 10px; /* Align with logout button */
        right: 60px; /* Adjust to be next to logout button */
        width: 40px; /* Size of the icon */
        height: 40px;
        border-radius: 50%; /* Make it circular */
        background-color: rgba(0, 0, 50, 0.8); /* Dark blue background */
        border: 2px solid #00ccff; /* Light blue border */
        box-shadow: 0 0 10px #00ccff; /* Glow effect */
        display: flex;
        justify-content: center;
        align-items: center;
        cursor: pointer;
        transition: transform 0.2s, box-shadow 0.2s;
        z-index: 10; /* Ensure it's above other elements if needed, same as logout */
    }

    #profileIcon:hover {
        transform: translateY(-2px);
        box-shadow: 0 0 15px #00ff00; /* Green glow on hover */
    }

    #profileIcon svg {
        width: 24px; /* Size of the SVG graphic inside */
        height: 24px;
        fill: #00ccff; /* Color of the SVG icon */
    }


    /* Lobby List & Single Lobby View */
    .lobby-list-container {
        display: none;
        flex-direction: column;
        align-items: center;
        background-color: rgba(0,0,50,0.9);
        border: 2px solid #00ccff;
        border-radius: 20px;
        padding: 20px;
        width: 90%;
        max-width: 800px;
        text-align: center;
        box-shadow: 0 0 20px #00ccff;
        margin-top: 50px;
        overflow-y: auto;
        max-height: 80vh;
    }

    .lobby-header {
        display: flex;
        justify-content: space-between; /* Pushes items to the ends */
        align-items: center;
        width: 100%;
        margin-bottom: 20px;
        /* Removed flex-wrap: wrap; for horizontal layout on larger screens */
        gap: 10px; /* Spacing between items */
    }

    .lobby-header button {
        /* No specific margins needed here, flexbox gap handles spacing */
        position: static; /* Ensure no absolute positioning interferes */
        margin: 0; /* Reset any default margins */
        flex-shrink: 0; /* Prevent buttons from shrinking too much */
    }
    .lobby-header h2 {
        flex-grow: 1; /* Allow the title to take up available space */
        text-align: center; /* Center the text within its flex item */
        margin: 0; /* Reset any default margins */
        white-space: nowrap; /* Prevent title from wrapping */
        overflow: hidden; /* Hide overflow if title is too long */
        text-overflow: ellipsis; /* Add ellipsis if title is too long */
    }

    .lobby-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 20px;
        width: 100%;
        padding: 10px;
    }

    .lobby-card {
        background-color: #001f3f;
        border: 2px solid #00ccff;
        border-radius: 15px;
        padding: 20px;
        cursor: pointer;
        transition: transform 0.2s, box-shadow 0.2s;
        text-align: left;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        min-height: 120px;
    }

    .lobby-card:hover {
        transform: translateY(-5px);
        box-shadow: 0 0 25px #00ccff;
    }

    .lobby-card h3 {
        margin: 0 0 10px 0;
        text-shadow: 0 0 5px #00ccff;
        font-size: 1.2em;
    }

    .lobby-card p {
        margin: 5px 0;
        font-size: 0.9em;
    }

    .lobby-card .join-btn {
        padding: 8px 15px;
        background-color: #004d40;
        border: 2px solid #00ccff;
        color: #00ccff;
        font-weight: bold;
        cursor: pointer;
        box-shadow: 0 0 10px #00ccff;
        border-radius: 8px;
        transition: background-color 0.2s, box-shadow 0.2s;
        margin-top: 10px;
        align-self: flex-end;
    }

    .lobby-card .join-btn:hover {
        background-color: #00645a;
        box-shadow: 0 0 15px #00ff00;
    }

    .lobby-card.full {
        opacity: 0.7;
        cursor: not-allowed;
        background-color: #333;
    }

    .lobby-card.full .join-btn {
        background-color: #666;
        border-color: #999;
        cursor: not-allowed;
        box-shadow: none;
    }

    #startGameButton {
        padding: 12px 25px;
        background-color: #008000;
        border: 2px solid #00ff00;
        color: #fff;
        font-weight: bold;
        cursor: pointer;
        box-shadow: 0 0 10px #00ff00;
        border-radius: 8px;
        transition: background-color 0.2s, box-shadow 0.2s;
        margin-top: 20px;
    }

    #startGameButton:hover:not(:disabled) {
        background-color: #00b300;
        box-shadow: 0 0 15px #00ff00;
    }

    #startGameButton:disabled {
        cursor: not-allowed;
        opacity: 0.5;
        background-color: #555;
        border-color: #888;
        box-shadow: none;
    }

    #currentLobbyInfo {
        margin-top: 10px;
        font-size: 1.1em;
        color: #fff;
        text-shadow: 0 0 5px #00ccff;
        display: block; /* Always display in single lobby view */
    }

    .player-status {
        font-size: 0.9em;
        font-weight: bold;
        padding: 4px 8px;
        border-radius: 10px;
        margin-left: 10px;
    }

    .player-status.ready {
        background-color: #00ff00;
        color: #003300;
    }

    .player-status.not-ready {
        background-color: #ff0000;
        color: #330000;
    }

    /* Main Content Wrapper (for game UI and solo challenge) */
    .main-content-wrapper {
        display: none; /* Managed by JS */
        flex-direction: row; /* Default to row for wider screens */
        gap: 20px;
        width: 98%; /* Increased width */
        max-width: 1600px; /* Increased max-width for game content */
        justify-content: center;
        align-items: stretch;
        flex-grow: 1;
        min-height: 80vh;
        flex-wrap: wrap;
        margin-bottom: 20px; /* Add some bottom margin */
    }

    /* Game UI (Common for 4v4 and 1v1) */
    #gameUI {
        display: none; /* Managed by JS */
        flex-direction: column;
        align-items: center;
        margin-top: 10px;
        flex-grow: 1;
        width: 100%; /* Ensure it takes full width when active */
    }

    /* New wrapper for 4v4 game area and chat */
    .multiplayer-game-area {
        display: flex;
        flex-direction: row; /* Arrange game and chat side-by-side */
        gap: 20px;
        width: 100%; /* Take full width of its parent */
        justify-content: space-between; /* Distribute space to push chat right */
        align-items: flex-start; /* Align items to the top */
        flex-wrap: wrap; /* Allow wrapping on smaller screens */
    }

    .game-container {
        position: relative;
        flex-grow: 1; /* Allow it to grow */
        min-width: 450px;
        max-width: 900px;
        height: 650px; /* Fixed height */
        border: 2px solid #00ccff;
        border-radius: 20px;
        box-shadow: 0 0 30px #00ccff inset;
        background-color: rgba(0, 0, 50, 0.9);
        overflow: hidden;
        margin: 0 auto; /* Center it horizontally */
    }

    .player-circle {
        position: absolute;
        width: 100%;
        height: 100%;
        pointer-events: none;
    }

    .player {
        position: absolute;
        width: 100px;
        text-align: center;
        transform: translate(-50%, -50%);
    }

    .player .name {
        font-weight: bold;
        font-size: 16px;
    }

    .player .name.active {
        color: yellow;
        text-shadow: 0 0 10px yellow;
    }

    .player .name.correct {
        color: lime;
        text-shadow: 0 0 10px lime;
    }

    .player .name.wrong {
        color: red;
        text-shadow: 0 0 10px red;
    }

    .player .lives {
        font-size: 12px;
    }

    #timer {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 48px;
        text-shadow: 0 0 10px #00ccff;
    }

    /* Common question box style */
    .question-box {
        position: absolute;
        bottom: 30px;
        left: 50%;
        transform: translateX(-50%);
        background-color: rgba(0,0,50,0.7);
        padding: 20px;
        border: 2px solid #00ccff;
        border-radius: 10px;
        box-shadow: 0 0 10px #00ccff;
        width: 90%;
        max-width: 700px;
        text-align: center;
        box-sizing: border-box;
    }

    .question-box input[type="text"] {
        padding: 10px;
        font-size: 16px;
        width: calc(70% - 15px);
        background-color: black;
        color: #00ccff;
        border: 1px solid #00ccff;
        border-radius: 5px;
        margin-right: 10px;
        box-sizing: border-box;
    }

    .question-box button {
        padding: 10px 20px;
        background-color: #001f3f;
        border: 2px solid #00ccff;
        color: #00ccff;
        font-weight: bold;
        cursor: pointer;
        box-shadow: 0 0 10px #00ccff;
        border-radius: 5px;
        transition: background-color 0.2s, box-shadow 0.2s;
    }
    .question-box button:hover {
        background-color: #003f6f;
        box-shadow: 0 0 15px #00ff00;
    }

    .replay-button {
        margin-top: 20px;
        display: none;
    }

    /* Leaderboard Styles */
    #leaderboard, #globalLeaderboard {
        margin-top: 20px;
        width: 95%;
        max-width: 900px;
        background-color: rgba(0,0,0,0.85);
        border: 3px solid #00ccff;
        border-radius: 20px;
        padding: 10px;
        color: #00ccff;
        font-size: 14px;
        font-weight: bold;
        text-align: center;
        box-shadow: 0 0 15px #00ccff;
        height: auto;
        margin-bottom: 20px;
    }

    #leaderboard table, #globalLeaderboard table {
        width: 100%;
        border-collapse: collapse;
        font-family: 'Orbitron', sans-serif;
    }

    #leaderboard th, #leaderboard td, #globalLeaderboard th, #globalLeaderboard td {
        padding: 12px 10px;
        border: 1px solid #00ccff;
    }

    #leaderboard thead, #globalLeaderboard thead {
        background-color: #000;
        color: #00ccff;
        font-size: 18px;
        text-shadow: 0 0 5px #00ccff;
    }

    #leaderboard tbody tr:nth-child(odd), #globalLeaderboard tbody tr:nth-child(odd) {
        background-color: rgba(0, 0, 50, 0.6);
    }

    #leaderboard tbody tr:nth-child(even), #globalLeaderboard tbody tr:nth-child(even) {
        background-color: rgba(0, 0, 100, 0.4);
    }

    #leaderboard tbody td, #globalLeaderboard tbody td {
        font-size: 16px;
    }

    /* Layout for 4v4 Q&A */
    #four-v-four-qna-layout {
        display: none; /* Managed by JS */
        flex-direction: column;
        align-items: center;
        gap: 20px;
        width: 100%;
        flex-grow: 1;
    }

    /* Layout for 1v1 Fill-in-the-Blanks */
    #one-v-one-fill-in-blanks-layout {
        display: none; /* Managed by JS */
        flex-direction: column;
        width: 100%;
        flex-grow: 1;
        gap: 20px;
    }

    .side-by-side-game-area {
        display: flex;
        justify-content: space-between; /* Distribute space to push chat right */
        gap: 20px;
        width: 100%;
        flex-grow: 1;
        align-items: flex-start; /* Align items to the top */
        flex-wrap: wrap; /* Ensure responsiveness */
    }

    /* New wrapper for 1v1 player panels to center them as a group */
    .player-panels-wrapper {
        display: flex;
        flex-direction: row;
        gap: 20px;
        flex-grow: 1; /* Allow it to take available space */
        justify-content: center; /* Center the two player panels within this wrapper */
        align-items: stretch; /* Make panels same height */
        min-width: 600px; /* Ensure enough space for two panels */
        max-width: 900px; /* Match game-container max-width */
        margin: 0 auto; /* Center the wrapper itself */
    }

    .player-panel {
        background-color: rgba(0, 0, 50, 0.9);
        border: 2px solid #00ccff;
        border-radius: 15px;
        box-shadow: 0 0 20px #00ccff;
        padding: 20px;
        flex: 1;
        min-width: 280px;
        text-align: center;
        position: relative;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
    }

    .player-panel.active-player-turn {
        border-color: yellow;
        box-shadow: 0 0 25px yellow;
    }

    .player-panel h3 {
        text-shadow: 0 0 8px #00ccff;
        margin-top: 0;
    }
    .player-panel p {
        font-size: 14px;
        margin-bottom: 5px;
    }

    /* 1v1 specific question box, positioned inside player panel */
    .question-box-1v1 {
        position: relative;
        background-color: rgba(0,0,50,0.9);
        padding: 15px;
        border: 1px solid #00ccff;
        border-radius: 8px;
        box-shadow: 0 0 8px #00ccff;
        width: calc(100% - 20px);
        margin-top: auto;
        margin-left: auto;
        margin-right: auto;
        box-sizing: border-box;
    }
    .question-box-1v1 input[type="text"] {
        padding: 10px;
        font-size: 16px;
        width: calc(100% - 80px);
        margin-right: 10px;
        background-color: black;
        color: #00ccff;
        border: 1px solid #00ccff;
        border-radius: 5px;
        box-sizing: border-box;
    }
    .question-box-1v1 button {
        padding: 10px 20px;
        background-color: #001f3f;
        border: 2px solid #00ccff;
        color: #00ccff;
        font-weight: bold;
        cursor: pointer;
        box-shadow: 0 0 10px #00ccff;
        border-radius: 5px;
        transition: background-color 0.2s, box-shadow 0.2s;
    }
    .question-box-1v1 button:hover {
        background-color: #003f6f;
        box-shadow: 0 0 15px #00ff00;
    }


    /* Chat box layout (common styles) */
    .chat-box-layout {
        background-color: rgba(0, 0, 50, 0.9);
        border: 2px solid #00ccff;
        border-radius: 10px;
        box-shadow: 0 0 20px #00ccff;
        padding: 15px;
        display: flex;
        flex-direction: column;
        min-height: 300px; /* Keep min-height for small screens */
        height: 650px; /* Make it same height as game-container */
        flex-shrink: 0; /* Prevent shrinking */
        flex-basis: 250px; /* Give it a preferred width */
        max-width: 300px; /* Optional: limit max width */
    }

    /* Adjustments for 4v4 chat box within the new layout */
    #chatBox4v4 {
        /* No specific order needed, it's already last in HTML */
        /* flex-basis and max-width from .chat-box-layout apply */
    }

    .chat-messages {
        flex-grow: 1;
        overflow-y: auto;
        border: 1px solid #00ccff;
        border-radius: 5px;
        padding: 10px;
        margin-bottom: 10px;
        background-color: rgba(0, 0, 0, 0.5);
        color: #00ccff;
        font-size: 14px;
        word-wrap: break-word;
        min-height: 150px;
    }

    .chat-box-layout input[type="text"] {
        padding: 8px;
        font-size: 14px;
        background-color: black;
        color: #00ccff;
        border: 1px solid #00ccff;
        border-radius: 5px;
        width: calc(100% - 16px);
        margin-bottom: 5px;
    }

    .chat-box-layout button {
        padding: 8px 15px;
        background-color: #001f3f;
        border: 2px solid #00ccff;
        color: #00ccff;
        font-weight: bold;
        cursor: pointer;
        box-shadow: 0 0 10px #00ccff;
        border-radius: 5px;
        width: 100%;
        transition: background-color 0.2s, box-shadow 0.2s;
    }
    .chat-box-layout button:hover {
        background-color: #003f6f;
        box-shadow: 0 0 15px #00ff00;
    }

    /* Adjustments for 1v1 chat box within the side-by-side layout */
    .middle-chat-divider {
        /* No specific order needed, it's already last in HTML */
        /* flex-basis and max-width from .chat-box-layout apply */
    }

    .ranking-area {
        width: 100%;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 20px;
        margin-top: 20px;
    }
    .ranking-area #leaderboard, .ranking-area #globalLeaderboard {
        width: 90%;
        max-width: 900px;
    }

    /* Solo Challenge UI */
    #soloChallengeUI {
        display: none; /* Managed by JS */
        flex-direction: column;
        align-items: center;
        background-color: rgba(0,0,50,0.9);
        border: 2px solid #00ccff;
        border-radius: 20px;
        box-shadow: 0 0 30px #00ccff inset;
        padding: 20px;
        width: 90%;
        max-width: 900px; /* Adjusted max-width for solo challenge */
        min-height: 650px;
        margin-top: 10px;
        position: relative;
        flex-grow: 1;
        box-sizing: border-box;
    }

    #soloChallengeUI h2 {
        margin-top: 0;
    }

    #soloProblemDescription {
        background-color: rgba(0,0,0,0.7);
        border: 1px solid #00ccff;
        border-radius: 8px;
        padding: 15px;
        margin-bottom: 15px;
        width: calc(100% - 30px);
        min-height: 80px;
        overflow-y: auto;
        font-size: 16px;
        box-sizing: border-box;
    }

    #soloCodeEditor {
        width: calc(100% - 20px);
        height: 200px;
        background-color: #000;
        color: #00ff00; /* Green text for code editor */
        border: 1px solid #00ccff;
        border-radius: 5px;
        padding: 10px;
        font-family: 'Courier New', monospace;
        font-size: 14px;
        resize: vertical;
        margin-bottom: 15px;
        box-sizing: border-box;
    }

    #soloChallengeButtons {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 15px;
        margin-bottom: 15px;
    }

    #soloChallengeButtons button {
        padding: 12px 25px;
    }

    #soloLoadingIndicator {
        display: none;
        text-align: center;
        margin-top: 10px;
        font-size: 18px;
        color: yellow;
    }

    #soloResult {
        background-color: rgba(0,0,0,0.7);
        border: 1px solid #00ccff;
        border-radius: 8px;
        padding: 15px;
        width: calc(100% - 30px);
        min-height: 80px;
        overflow-y: auto;
        font-size: 14px;
        white-space: pre-wrap;
        box-sizing: border-box;
    }

    /* Custom Modal for Alerts */
    .custom-modal {
        display: none; /* Corrected: Initially hidden by default */
        position: fixed;
        z-index: 20;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        overflow: auto;
        background-color: rgba(0,0,0,0.8);
        justify-content: center;
        align-items: center;
    }

    .custom-modal-content {
        background-color: rgba(0,0,50,0.95);
        margin: auto;
        padding: 30px;
        border: 3px solid #00ccff;
        border-radius: 15px;
        width: 90%;
        max-width: 400px;
        text-align: center;
        box-shadow: 0 0 25px #00ccff;
        transform: scale(0.95);
        animation: modalFadeIn 0.3s forwards;
        color: #fff;
    }

    .custom-modal-content h3 {
        margin-top: 0;
        margin-bottom: 20px;
        font-size: 24px;
    }

    .custom-modal-content p {
        font-size: 16px;
        margin-bottom: 25px;
        line-height: 1.5;
    }

    /* Apply primary-btn style to modal buttons */
    .custom-modal-content button {
        padding: 12px 25px; /* Adjust padding for modal buttons */
        font-size: 18px; /* Adjust font size for modal buttons */
        width: auto; /* Allow buttons to size content */
        min-width: 100px; /* Ensure a minimum width */
        margin: 0 5px; /* Spacing between buttons */
    }

    @keyframes modalFadeIn {
        from { opacity: 0; transform: scale(0.8); }
        to { opacity: 1; transform: scale(1); }
    }

    /* Create Lobby Modal */
    #createLobbyModal {
        display: none; /* Hidden by default */
        position: fixed;
        z-index: 20;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        overflow: auto;
        background-color: rgba(0,0,0,0.8);
        justify-content: center;
        align-items: center;
    }

    #createLobbyModal .custom-modal-content {
        padding: 25px;
        max-width: 450px;
    }

    #createLobbyModal .custom-modal-content h3 {
        margin-bottom: 15px;
        font-size: 22px;
    }

    #createLobbyModal .custom-modal-content label {
        display: block;
        text-align: left;
        margin-bottom: 8px;
        color: #00ccff;
        font-size: 15px;
    }

    #createLobbyModal .custom-modal-content input[type="text"],
    #createLobbyModal .custom-modal-content select {
        width: calc(100% - 20px);
        padding: 10px;
        margin-bottom: 20px;
        background-color: black;
        color: #00ccff;
        border: 1px solid #00ccff;
        border-radius: 5px;
        font-size: 16px;
        box-sizing: border-box;
    }

    #createLobbyModal .custom-modal-content select {
        appearance: none;
        -webkit-appearance: none;
        -moz-appearance: none;
        background-image: url('data:image/svg+xml;utf8,<svg fill="%2300ccff" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M7 10l5 5 5-5z"/></svg>');
        background-repeat: no-repeat;
        background-position: right 10px center;
        background-size: 16px;
    }

    .modal-buttons {
        display: flex;
        justify-content: center;
        margin-top: 10px;
    }
    .modal-buttons button {
        width: auto;
        min-width: 120px;
        margin: 0 10px;
    }

    /* Responsive adjustments */
    @media (max-width: 992px) {
        #mainLobbyDashboard {
            flex-direction: column;
            align-items: center;
        }
        .left-panel-modes, .center-panel-leaderboard, .right-panel-updates {
            width: 95%;
            max-width: 600px; /* Adjust max-width for panels on smaller screens */
            flex: none; /* Disable flex-grow on smaller screens when stacked */
        }
        #gameModeSelection, #rankedGameModeSelection { /* Added #rankedGameModeSelection */
            width: 95%;
            max-width: 600px;
        }
        .game-container, #soloChallengeUI {
            width: 95%;
            max-width: 650px;
        }
        .side-by-side-game-area {
            flex-direction: column;
        }
        .multiplayer-game-area {
            flex-direction: column; /* Stack vertically on smaller screens */
            align-items: center; /* Center items when stacked */
        }
        #chatBox4v4, .game-container, .player-panels-wrapper, .middle-chat-divider, .player-panel {
            width: 95%; /* Take full width on smaller screens */
            max-width: 650px; /* Limit max width */
            flex: none; /* Disable flex-grow/shrink when stacked */
            height: auto; /* Allow height to adjust when stacked */
            margin: 0 auto; /* Center when stacked */
        }
        .middle-chat-divider {
            order: unset; /* Reset order for stacking */
        }
        #profileIcon { /* Adjust position for smaller screens if needed */
            top: 10px;
            right: 50px; /* Adjusted right position for smaller screens */
            width: 35px;
            height: 35px;
        }
        #profileIcon svg {
            width: 20px;
            height: 20px;
        }
    }

    @media (max-width: 768px) {
        h1 { font-size: 28px; }
        .game-mode-box, .lobby-card, #authContainer {
            padding: 20px;
        }
        .game-mode-box h3 { font-size: 20px; }
        .lobby-header {
            flex-direction: column; /* Stack items vertically on smaller screens */
            align-items: center; /* Center items horizontally when stacked */
            gap: 10px; /* Maintain gap for vertical stacking */
        }
        .lobby-header button {
            margin: 0; /* Reset margins, gap will handle spacing */
            margin-bottom: 0px;
        }
        .lobby-header h2 {
            font-size: 24px;
            margin: 0; /* Reset margins, gap will handle spacing */
            margin-bottom: 0px;
            white-space: normal; /* Allow title to wrap on smaller screens */
        }
        .question-box, .question-box-1v1 {
            padding: 15px;
            width: 95%;
        }
        .question-box input[type="text"], .question-box-1v1 input[type="text"] {
            width: calc(100% - 60px);
        }
        .player {
            width: 80px;
            height: 80px;
            font-size: 10px;
        }
        .player .name { font-size: 14px; }
        .player .lives { font-size: 10px; }
        #timer { font-size: 36px; }
        #leaderboard, #globalLeaderboard {
            width: 98%;
            padding: 8px;
        }
        #leaderboard th, #leaderboard td, #globalLeaderboard th, #globalLeaderboard td {
            padding: 8px 5px;
            font-size: 12px;
        }
        #leaderboard thead, #globalLeaderboard thead { font-size: 16px; }
        #soloChallengeUI { min-height: 500px; }
        #soloCodeEditor { height: 150px; }
        .custom-modal-content { padding: 20px; }
        .custom-modal-content h3 { font-size: 20px; }
        .custom-modal-content p { font-size: 14px; }
        /* Adjust modal buttons for smaller screens */
        .custom-modal-content button {
            padding: 10px 20px;
            font-size: 16px;
            min-width: 80px;
        }
    }
</style>
</head>
<body>
<h1>Code Rivals</h1>

<button id="logoutBtn" class="primary-btn">Logout</button>
<div id="welcomeMessage"></div>

<!-- Profile Icon - Moved outside mainLobbyDashboard -->
<div id="profileIcon" onclick="showCustomModal('Profile', 'Your profile information will go here!')">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/>
    </svg>
</div>

<div id="authContainer">
    <h2 id="authTitle">Login</h2>
    <input type="text" id="usernameInput" placeholder="Username" autocomplete="username">
    <input type="password" id="passwordInput" placeholder="Password" autocomplete="current-password">
    <button id="authSubmitBtn" class="primary-btn">Login</button>
    <div id="authSwitch">Don't have an account? Sign Up</div>
</div>

<!-- Main Lobby Dashboard (New Section) -->
<div id="mainLobbyDashboard">
    <div class="main-panel left-panel-modes">
        <h2>Game Modes</h2>
        <button id="casualModeBtn" class="primary-btn">Casual</button>
        <button id="rankedModeBtn" class="primary-btn">Ranked</button>
        <button id="customModeBtn" class="primary-btn">Custom</button>
    </div>

    <div class="main-panel center-panel-leaderboard">
        <div id="globalLeaderboard">
            <h2>Global Leaderboard</h2>
            <table>
                <thead><tr><th>Rank</th><th>Player</th><th>ELO</th><th>Accuracy</th></tr></thead>
                <tbody id="globalLeaderboardBody"></tbody>
            </table>
        </div>
    </div>

    <div class="main-panel right-panel-updates"> <!-- Renamed class -->
        <h3>Update Logs</h3>
        <ul id="updates">
            <li>v0.1 - Initial release</li>
            <li>v0.2 - Lobby and Login separation</li>
            <li>v0.3 - Persistent leaderboard (local file system)</li>
            <li>v0.4 - Video background added</li>
            <li>v0.5 - Consolidated frontend logic</li>
            <li>v0.6 - Client-side login/signup, in-memory lobbies</li>
            <li>v0.7 - Hidden ranked lobbies with mode selection</li>
            <li>v0.8 - Direct entry to ranked lobbies, all players visible in-game, auto ready-up for ranked.</li>
        </ul>
    </div>
</div>


<div id="gameModeSelection">
    <h2>Choose Your Casual Game Mode</h2>
    <div class="game-mode-box" id="four-v-four-qna-mode">
        <h3>Free for All Q&A</h3>
        <p>Compete with up to 4 players in a fast-paced Q&A challenge.</p>
    </div>
    <div class="game-mode-box" id="one-v-one-fill-in-blanks-mode">
        <h3>1v1 Fill in the Blanks</h3>
        <p>A head-to-head battle, filling in missing code for C++ beginners.</p>
    </div>
    <div class="game-mode-box" id="solo-coding-challenge-mode">
        <h3>Solo Coding Challenge</h3>
        <p>Improve your skills by solving C++ problems, evaluated by AI.</p>
    </div>
    <button class="back-to-dashboard-btn primary-btn">Back to Dashboard</button>
</div>

<!-- New Ranked Game Mode Selection -->
<div id="rankedGameModeSelection">
    <h2>Choose Your Ranked Game Mode</h2>
    <div class="game-mode-box" id="ranked-four-v-four-qna-mode">
        <h3>Ranked Free for All Q&A</h3>
        <p>Compete in a ranked 4-player Q&A match to climb the leaderboard.</p>
    </div>
    <div class="game-mode-box" id="ranked-one-v-one-fill-in-blanks-mode">
        <h3>Ranked 1v1 Fill in the Blanks</h3>
        <p>A ranked head-to-head battle, filling in missing code for ELO.</p>
    </div>
    <button class="back-to-dashboard-btn primary-btn">Back to Dashboard</button>
</div>


<!-- Lobby List Container -->
<div id="lobbyListContainer" class="lobby-list-container">
    <div class="lobby-header">
        <button class="back-to-mode-selection-btn primary-btn">Back to Mode Select</button>
        <h2 id="lobbyListTitle">Available Lobbies</h2>
        <button class="primary-btn" id="createNewLobbyBtn">Create New Lobby</button>
    </div>
    <div id="lobbiesGrid" class="lobby-grid">
        <!-- Lobbies will be dynamically loaded here -->
    </div>
</div>

<!-- Single Lobby View -->
<div id="singleLobbyView" class="lobby-list-container">
    <div class="lobby-header">
        <button class="back-to-lobbies-btn primary-btn">Leave Lobby</button>
        <h2 id="currentLobbyTitle"></h2>
        <button id="readyToggleBtn" class="primary-btn">Ready Up!</button>
    </div>
    <p id="currentLobbyInfo">Lobby ID: <span id="displayLobbyId"></span> | Players: <span id="displayPlayerCount">0</span>/<span id="displayMaxPlayers">0</span> | Status: <span id="displayLobbyStatus"></span></p>
    <div id="lobbyPlayersDisplay" class="lobby-grid">
        <!-- Players in the current lobby will be displayed here -->
    </div>
    <button id="startGameButton" class="primary-btn" disabled>Start Game</button>
</div>


<div class="main-content-wrapper">
    <div id="gameUI">
        <!-- Layout specific to 4v4 Q&A -->
        <div id="four-v-four-qna-layout">
            <div class="multiplayer-game-area"> <!-- New wrapper div -->
                <div class="game-container">
                    <button id="backToLobbyBtn4v4" class="primary-btn">Back to Lobbies</button>
                    <div class="player-circle" id="playerCircle"></div>
                    <div id="timer">30</div>
                    <div id="questionBox4v4" class="question-box">
                        <p id="question4v4">Loading...</p>
                        <input type="text" id="answerInput4v4" placeholder="Your answer here" />
                        <button id="submitAnswerBtn4v4">Submit</button>
                    </div>
                </div>
                <div id="chatBox4v4" class="chat-box-layout">
                    <h3>Lobby Chat</h3>
                    <div id="chatMessages4v4" class="chat-messages"></div>
                    <input type="text" id="chatInput4v4" placeholder="Type your message..." />
                    <button id="sendChatBtn4v4">Send</button>
                </div>
            </div>
            <!-- Ranking Area (common for multiplayer) -->
            <div class="ranking-area">
                <div id="leaderboard">
                    <h2>Current Round Leaderboard</h2>
                    <table>
                        <thead><tr><th>Rank</th><th>Player</th><th>ELO</th><th>Accuracy</th></tr></thead>
                        <tbody id="leaderboardBody"></tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- Layout specific to 1v1 Fill-in-the-Blanks -->
        <div id="one-v-one-fill-in-blanks-layout">
            <button id="backToLobbyBtn1v1" class="primary-btn">Back to Lobbies</button>
            <div class="side-by-side-game-area">
                <div class="player-panels-wrapper"> <!-- New wrapper for player panels -->
                    <div class="player-panel" id="player1-panel">
                        <h3 class="player-panel-name"><span id="player1-name"></span> <span id="player1-you-tag"></span></h3>
                        <p>Lives: <span id="player1-lives"></span></p>
                        <p>ELO: <span id="player1-elo"></span></p>
                        <div id="questionBox1v1Player1" class="question-box-1v1">
                             <p id="question1v1Player1"></p>
                             <input type="text" id="answerInput1v1Player1" placeholder="Your answer here" />
                             <button id="submitAnswerBtn1v1Player1">Submit</button>
                        </div>
                    </div>
                    <div class="player-panel" id="player2-panel">
                        <h3 class="player-panel-name"><span id="player2-name"></span> <span id="player2-you-tag"></span></h3>
                        <p>Lives: <span id="player2-lives"></span></p>
                        <p>ELO: <span id="player2-elo"></span></p>
                        <div id="questionBox1v1Player2" class="question-box-1v1">
                             <p id="question1v1Player2"></p>
                             <input type="text" id="answerInput1v1Player2" placeholder="Your answer here" />
                             <button id="submitAnswerBtn1v1Player2">Submit</button>
                        </div>
                    </div>
                </div>
                <div id="chatBox1v1" class="chat-box-layout middle-chat-divider">
                    <h3>Lobby Chat</h3>
                    <div id="chatMessages1v1" class="chat-messages"></div>
                    <input type="text" id="chatInput1v1" placeholder="Type your message..." />
                    <button id="sendChatBtn1v1">Send</button>
                </div>
            </div>
            <!-- Ranking Area (common for multiplayer) -->
            <div class="ranking-area">
                <div id="leaderboard">
                    <h2>Current Round Leaderboard</h2>
                    <table>
                        <thead><tr><th>Rank</th><th>Player</th><th>ELO</th><th>Accuracy</th></tr></thead>
                        <tbody id="leaderboardBody"></tbody>
                    </table>
                </div>
            </div>
        </div>

        <div class="replay-button" id="replayButton">
            <button class="primary-btn">Replay</button>
        </div>
    </div>

    <!-- Solo Challenge UI -->
    <div id="soloChallengeUI">
        <button id="soloBackToLobbyBtn" class="primary-btn">Back to Mode Select</button>
        <h2>Solo Coding Challenge - Stage <span id="soloCurrentStage">1</span></h2>
        <div id="soloProblemDescription"></div>
        <textarea id="soloCodeEditor" placeholder="Write your C++ code here..."></textarea>
        <div id="soloChallengeButtons">
            <button id="soloPrevStageBtn" class="primary-btn" disabled>Previous Stage</button>
            <button id="runCodeBtn" class="primary-btn">Run Code</button>
            <button id="soloNextStageBtn" class="primary-btn" disabled>Next Stage</button>
        </div>
        <div id="soloLoadingIndicator">Evaluating code...</div>
        <div id="soloResult"></div>
    </div>
</div>

<div id="customModal" class="custom-modal">
    <div class="custom-modal-content">
        <h3 id="modalTitle"></h3>
        <p id="modalMessage"></p>
        <button class="primary-btn">OK</button> <!-- Added primary-btn class -->
    </div>
</div>

<div id="createLobbyModal" class="custom-modal">
    <div class="custom-modal-content">
        <h3>Create New Lobby</h3>
        <label for="new-lobby-name">Lobby Name:</label>
        <input type="text" id="new-lobby-name" placeholder="Enter lobby name" required>

        <label for="new-lobby-max-players">Max Players:</label>
        <select id="new-lobby-max-players">
            <!-- Options will be dynamically populated by JavaScript -->
        </select>

        <div class="modal-buttons">
            <button class="primary-btn" id="confirmCreateLobbyBtn">Create</button>
            <button class="primary-btn" id="cancelCreateLobbyBtn">Cancel</button>
        </div>
    </div>
</div>

<script>
    // Global game state variables
    let currentUser = null; // Stores currently logged-in user's data from in-memory 'users' object
    let userId = null; // Unique ID for the current user (from in-memory 'users' object)
    let currentLobbyType = ''; // '4v4-qna', '1v1-fill-in-blanks', 'solo-coding-challenge', 'ranked-1v1'
    let currentLobbyId = ''; // ID of the currently joined lobby
    // Removed: let generalChatMessages = []; // In-memory chat for the main lobby dashboard

    // In-memory "database" for user credentials and stats (NO PERSISTENCE ACROSS BROWSER SESSIONS)
    // Stores { username: { id: "uniqueId", password: "password", soloStage: 0, correctAnswers: 0, totalAnswers: 0, elo: 0 } }
    const users = {};
    let nextUserId = 1; // Simple counter for unique user IDs for in-memory users

    // In-memory "database" for active lobbies (NO PERSISTENCE ACROSS BROWSER SESSIONS)
    // Stores { lobbyId: { id: "...", name: "...", type: "...", players: [], maxPlayers: N, gameStarted: false, chatMessages: [] } }
    const activeLobbies = {};

    let players = []; // Local array of players in the current game (multiplayer modes)
    let isPlayerReady = false; // Current user's ready status in the current lobby

    // Game variables for Q&A / Fill-in-the-blanks modes
    let questions = []; // Questions for the current game round
    let currentQuestionIndex = 0; // Index of the current question
    let currentPlayerIndex = 0; // Index of the player whose turn it is
    let timeLeft = 30; // Time left for current question
    let timer; // Interval ID for the game timer

    // Solo Challenge variables
    let currentSoloStage = 0; // Index for soloChallenges array - will be loaded from user data

    // API Key for Gemini. This will be provided by the Canvas runtime.
    const API_KEY = "";
    const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${API_KEY}`;

    // Backend URL for global leaderboard and Gemini proxy (if used)
    // IMPORTANT: Replace with your actual DEPLOYED Render backend URL if you deploy it.
    const BACKEND_URL = "http://localhost:3000"; // Default for local development
    const socket = io(BACKEND_URL); // Initialize Socket.IO connection

    // Pre-defined game questions
    const originalQuestions = [
        { q: "What is the output of: cout << 2 + 2;", a: "4" },
        { q: "Which keyword is used for constant?", a: "const" },
        { q: "How many bytes is an int?", a: "4" },
        { q: "C++ pointer access operator?", a: "->" },
        { q: "Declare a pointer to int", a: "int* ptr;" }
    ];

    const fillInBlanksQuestions = [
        { q: "int main() { cout << \"Hello, ___\"; return 0; }", a: "world", hint: "Common greeting" },
        { q: "int ___ = 10;", a: "x", hint: "A common variable name" },
        { q: "for (int i = 0; i < ___; i++)", a: "10", hint: "A typical loop limit" },
        { q: "class MyClass { public: MyClass() { /* constructor */ } };", a: "MyClass", hint: "Name of the class" },
        { q: "std::string ___ = \"C++\";", a: "language", hint: "What is C++?" }
    ];

    // Solo Coding Challenges
    const soloChallenges = [
        {
            stage: 1,
            title: "Hello World!",
            problem: "Write a C++ program that prints 'Hello, World!' to the console. The output must exactly match 'Hello, World!' followed by a newline.",
            expectedOutput: "Hello, World!\n",
            initialCode: `#include <iostream>\n\nint main() {\n  std::cout << "Hello, World!" << std::endl;\n  return 0;\n}`
        },
        {
            stage: 2,
            title: "Add Two Numbers",
            problem: "Write a C++ program that declares two integer variables, `a` and `b`, initializes them to 5 and 7 respectively, and prints their sum to the console. The output must be exactly '12' followed by a newline.",
            expectedOutput: "12\n",
            initialCode: `#include <iostream>\n\nint main() {\n  int a = 5;\n  int b = 7;\n  std::cout << (a + b) << std::endl;\n  return 0;\n}`
        },
        {
            stage: 3,
            title: "Conditional Statement (If-Else)",
            problem: "Write a C++ program that declares an integer variable `num` and initializes it to 10. If `num` is greater than 5, print 'Greater than 5'; otherwise, print 'Not greater than 5'. The output must be exactly 'Greater than 5' followed by a newline.",
            expectedOutput: "Greater than 5\n",
            initialCode: `#include <iostream>\n\nint main() {\n  int num = 10;\n  if (num > 5) {\n    std::cout << "Greater than 5" << std::endl;\n  } else {\n    std::cout << "Not greater than 5" << std::endl;\n  }\n  return 0;\n}`
        },
        {
            stage: 4,
            title: "Simple Loop (For loop)",
            problem: "Write a C++ program that uses a for loop to print numbers from 1 to 3, each on a new line. The output must be exactly '1\\n2\\n3\\n'.",
            expectedOutput: "1\n2\n3\n",
            initialCode: `#include <iostream>\n\nint main() {\n  for (int i = 1; i <= 3; ++i) {\n    std::cout << i << std::endl;\n  }\n  return 0;\n}`
        },
        {
            stage: 5,
            title: "Basic Function",
            problem: "Write a C++ program with a function named `add` that takes two integers as parameters and returns their sum. In `main`, call `add` with 15 and 20 and print the result. The output must be exactly '35' followed by a newline.",
            expectedOutput: "35\n",
            initialCode: `#include <iostream>\n\nint add(int a, int b) {\n  return a + b;\n}\n\nint main() {\n  std::cout << add(15, 20) << std::endl;\n  return 0;\n}`
        },
        {
            stage: 6,
            title: "Factorial Calculation",
            problem: "Write a C++ program to calculate the factorial of a number (e.g., 5). Print the result. The output must be exactly '120' followed by a newline. (Factorial of 5 is 5*4*3*2*1 = 120)",
            expectedOutput: "120\n",
            initialCode: `#include <iostream>\n\nint main() {\n  int n = 5;\n  long long factorial = 1;\n\n  for (int i = 1; i <= n; ++i) {\n    factorial *= i;\n  }\n\n  std::cout << factorial << std::endl;\n  return 0;\n}`
        },
        {
            stage: 7,
            title: "Array Sum",
            problem: "Write a C++ program that initializes an integer array with values {10, 20, 30}. Calculate the sum of its elements and print the sum. The output must be exactly '60' followed by a newline.",
            expectedOutput: "60\n",
            initialCode: `#include <iostream>\n#include <vector>\n\nint main() {\n  std::vector<int> numbers = {10, 20, 30};\n  int sum = 0;\n\n  for (int num : numbers) {\n    sum += num;\n}\n\n  std::cout << sum << std::endl;\n  return 0;\n}`
        }
    ];

    // --- DOM Element References ---
    const authContainer = document.getElementById('authContainer');
    const gameModeSelection = document.getElementById('gameModeSelection');
    const rankedGameModeSelection = document.getElementById('rankedGameModeSelection'); // New reference
    const mainLobbyDashboard = document.getElementById('mainLobbyDashboard'); // New reference
    const lobbyListContainer = document.getElementById('lobbyListContainer');
    const singleLobbyView = document.getElementById('singleLobbyView');
    const mainContentWrapper = document.querySelector('.main-content-wrapper');
    const gameUI = document.getElementById('gameUI');
    const soloChallengeUI = document.getElementById('soloChallengeUI');

    const logoutBtn = document.getElementById('logoutBtn');
    const welcomeMessage = document.getElementById('welcomeMessage');
    const profileIcon = document.getElementById('profileIcon'); // Get reference to the profile icon

    const usernameInput = document.getElementById('usernameInput');
    const passwordInput = document.getElementById('passwordInput');
    const authTitle = document.getElementById('authTitle');
    const authSubmitBtn = document.getElementById('authSubmitBtn');
    const authSwitch = document.getElementById('authSwitch');

    const modalTitle = document.getElementById('modalTitle');
    const modalMessage = document.getElementById('modalMessage');
    const customModal = document.getElementById('customModal');
    const customModalOkBtn = customModal.querySelector('button');

    const createLobbyModal = document.getElementById('createLobbyModal');
    const newLobbyNameInput = document.getElementById('new-lobby-name');
    const newLobbyMaxPlayersSelect = document.getElementById('new-lobby-max-players');
    const confirmCreateLobbyBtn = document.getElementById('confirmCreateLobbyBtn');
    const cancelCreateLobbyBtn = document.getElementById('cancelCreateLobbyBtn');

    const lobbiesGrid = document.getElementById('lobbiesGrid');
    const lobbyListTitle = document.getElementById('lobbyListTitle');
    const currentLobbyTitle = document.getElementById('currentLobbyTitle');
    const displayLobbyId = document.getElementById('displayLobbyId');
    const displayPlayerCount = document.getElementById('displayPlayerCount');
    const displayMaxPlayers = document.getElementById('displayMaxPlayers');
    const displayLobbyStatus = document.getElementById('displayLobbyStatus');
    const lobbyPlayersDisplay = document.getElementById('lobbyPlayersDisplay');
    const readyToggleBtn = document.getElementById('readyToggleBtn');
    const startGameButton = document.getElementById('startGameButton');
    const createNewLobbyBtn = document.getElementById('createNewLobbyBtn'); // Added reference

    const fourVFourQnALayout = document.getElementById('four-v-four-qna-layout');
    const oneVOneFillInBlanksLayout = document.getElementById('one-v-one-fill-in-blanks-layout');
    const playerCircleDiv = document.getElementById('playerCircle');
    const gameTimerDisplay = document.getElementById('timer');
    const question4v4Display = document.getElementById('question4v4');
    const answerInput4v4 = document.getElementById('answerInput4v4');
    const submitAnswerBtn4v4 = document.getElementById('submitAnswerBtn4v4');
    const replayButton = document.getElementById('replayButton');

    const player1Panel = document.getElementById('player1-panel');
    const player2Panel = document.getElementById('player2-panel'); // Corrected typo here
    const player1Name = document.getElementById('player1-name');
    const player1YouTag = document.getElementById('player1-you-tag');
    const player1Lives = document.getElementById('player1-lives');
    const player1Elo = document.getElementById('player1-elo');
    const player2Name = document.getElementById('player2-name');
    const player2YouTag = document.getElementById('player2-you-tag');
    const player2Lives = document.getElementById('player2-lives');
    const player2Elo = document.getElementById('player2-elo');
    const questionBox1v1Player1 = document.getElementById('questionBox1v1Player1');
    const question1v1Player1 = document.getElementById('question1v1Player1');
    const answerInput1v1Player1 = document.getElementById('answerInput1v1Player1');
    const submitAnswerBtn1v1Player1 = document.getElementById('submitAnswerBtn1v1Player1');
    const questionBox1v1Player2 = document.getElementById('questionBox1v1Player2');
    const question1v1Player2 = document.getElementById('question1v1Player2');
    const answerInput1v1Player2 = document.getElementById('answerInput1v1Player2');
    const submitAnswerBtn1v1Player2 = document.getElementById('submitAnswerBtn1v1Player2');


    const soloCurrentStageSpan = document.getElementById('soloCurrentStage');
    const soloProblemDescription = document.getElementById('soloProblemDescription');
    const soloCodeEditor = document.getElementById('soloCodeEditor');
    const soloPrevStageBtn = document.getElementById('soloPrevStageBtn');
    const soloNextStageBtn = document = document.getElementById('soloNextStageBtn');
    const runCodeBtn = document.getElementById('runCodeBtn');
    const soloLoadingIndicator = document.getElementById('soloLoadingIndicator');
    const soloResult = document.getElementById('soloResult');

    const chatMessages4v4Div = document.getElementById('chatMessages4v4');
    const chatInput4v4 = document.getElementById('chatInput4v4');
    const sendChatBtn4v4 = document.getElementById('sendChatBtn4v4');
    const chatBox4v4 = document.getElementById('chatBox4v4');

    const chatMessages1v1Div = document.getElementById('chatMessages1v1');
    const chatInput1v1 = document.getElementById('chatInput1v1');
    const sendChatBtn1v1 = document.getElementById('sendChatBtn1v1');
    const chatBox1v1 = document.getElementById('chatBox1v1');

    const leaderboardBody = document.getElementById('leaderboardBody');
    const globalLeaderboardBody = document.getElementById('globalLeaderboardBody');

    const backToDashboardBtns = document.querySelectorAll('.back-to-dashboard-btn'); // Changed to querySelectorAll


    // --- Utility Functions ---

    let resolveModalPromise; // Used to resolve the promise for showCustomModal

    /**
     * Displays a custom modal message. Can be used as an alert or a confirmation.
     * @param {string} title The title of the modal.
     * @param {string} message The message content.
     * @param {boolean} isConfirm If true, adds a "Cancel" button and returns a Promise resolving to true/false.
     * @returns {Promise<boolean>} Resolves to true for OK/Confirm, false for Cancel.
     */
    function showCustomModal(title, message, isConfirm = false) {
        return new Promise((resolve) => {
            modalTitle.textContent = title;
            modalMessage.textContent = message;

            // Remove any old "Cancel" button before adding new ones
            const oldCancelButton = customModalOkBtn.parentNode.querySelector('.cancel-button');
            if (oldCancelButton) {
                oldCancelButton.remove();
            }

            if (isConfirm) {
                const cancelButton = document.createElement('button');
                cancelButton.textContent = 'Cancel';
                cancelButton.className = 'primary-btn cancel-button'; // Use primary-btn class
                cancelButton.style.backgroundColor = '#666';
                cancelButton.style.borderColor = '#999';
                cancelButton.style.marginLeft = '10px';
                cancelButton.onclick = () => {
                    closeModal();
                    resolve(false); // Resolve with false for cancel
                };
                customModalOkBtn.parentNode.insertBefore(cancelButton, customModalOkBtn.nextSibling);
                customModalOkBtn.textContent = 'Confirm';
                customModalOkBtn.onclick = () => {
                    closeModal();
                    resolve(true); // Resolve with true for confirm
                };
            } else {
                customModalOkBtn.textContent = 'OK';
                customModalOkBtn.onclick = () => {
                    closeModal();
                    resolve(true); // Resolve with true for OK
                };
            }
            resolveModalPromise = resolve; // Store resolve function for direct calls to closeModal
            customModal.style.display = 'flex';
        });
    }

    /**
     * Hides the custom modal.
     */
    function closeModal() {
        customModal.style.display = 'none';
        // If a promise is pending, resolve it when modal is closed directly
        if (resolveModalPromise) {
            resolveModalPromise(true); // Assume OK if closed without explicit button click
            resolveModalPromise = null;
        }
    }

    /**
     * Shows a specific section and hides others. Manages main-content-wrapper and chatbox visibility.
     * @param {HTMLElement} sectionElement The section DOM element to show.
     */
    function showSection(sectionElement) {
        const sections = [authContainer, gameModeSelection, rankedGameModeSelection, mainLobbyDashboard, lobbyListContainer, singleLobbyView, gameUI, soloChallengeUI];
        sections.forEach(sec => {
            if (sec) {
                sec.style.display = 'none';
            }
        });

        if (sectionElement) {
            sectionElement.style.display = 'flex'; // Most sections are flex containers
        }

        // Adjust main-content-wrapper display based on the active section
        // mainLobbyDashboard is now also a "main content" type display
        if (sectionElement === gameUI || sectionElement === soloChallengeUI || sectionElement === mainLobbyDashboard) {
            mainContentWrapper.style.display = 'flex';
        } else {
            mainContentWrapper.style.display = 'none'; // Hide main wrapper if not in game/solo mode
        }

        // Hide all specific game layouts and chat boxes when switching sections
        fourVFourQnALayout.style.display = 'none';
        oneVOneFillInBlanksLayout.style.display = 'none';
        chatBox4v4.style.display = 'none'; // Ensure these are hidden when changing sections
        chatBox1v1.style.display = 'none'; // Ensure these are hidden when changing sections

        // Manage visibility of 'Create New Lobby' button based on section
        // Hide 'Create New Lobby' button if currentLobbyType starts with 'ranked-'
        if (sectionElement === lobbyListContainer && !currentLobbyType.startsWith('ranked-')) {
            createNewLobbyBtn.style.display = 'block';
        } else {
            createNewLobbyBtn.style.display = 'none';
        }

        // Show/hide profile icon based on whether mainLobbyDashboard is visible
        if (profileIcon) {
            profileIcon.style.display = (sectionElement === mainLobbyDashboard) ? 'flex' : 'none';
        }
    }

    // --- Authentication Functions (In-Memory Client-Side) ---
    let isLoginMode = true; // true for login, false for signup

    /**
     * Toggles the authentication form between Login and Sign Up modes.
     */
    function toggleAuthMode() {
        isLoginMode = !isLoginMode;
        authTitle.textContent = isLoginMode ? "Login" : "Sign Up";
        authSubmitBtn.textContent = isLoginMode ? "Login" : "Sign Up";
        authSwitch.textContent = isLoginMode ? "Don't have an account? Sign Up" : "Already have an account? Login";
        usernameInput.value = '';
        passwordInput.value = '';
    }

    /**
     * Handles user login or signup based on the current mode.
     * Stores user data in an in-memory 'users' object (not persistent).
     */
    async function authAction() {
        const username = usernameInput.value.trim();
        const password = passwordInput.value.trim();

        if (!username || !password) {
            await showCustomModal("Error", "Username and password cannot be empty.");
            return;
        }

        if (isLoginMode) {
            // Login existing user
            if (users[username] && users[username].password === password) {
                currentUser = {
                    id: users[username].id,
                    username: username,
                    lives: 3, // Default lives for game
                    elo: users[username].elo,
                    soloStage: users[username].soloStage,
                    correctAnswers: users[username].correctAnswers,
                    totalAnswers: users[username].totalAnswers
                };
                userId = currentUser.id; // Set userId for the session
                handleSuccessfulAuth();
            } else {
                await showCustomModal("Error", "Invalid username or password.");
            }
        } else {
            // Register new user
            if (users[username]) {
                await showCustomModal("Error", "Username already exists. Please choose a different one.");
                return;
            }
            const newId = `user_${nextUserId++}`;
            users[username] = {
                id: newId,
                password: password,
                soloStage: 0,
                correctAnswers: 0,
                totalAnswers: 0,
                elo: 1000 // Starting ELO for new users
            };
            await showCustomModal("Success", `Account for "${username}" created! Please login.`);
            toggleAuthMode(); // Switch to login mode
            usernameInput.value = username;
            passwordInput.value = '';
        }
    }

    /**
     * Handles user logout. Clears current user session and resets UI.
     */
    async function logout() {
        const confirmed = await showCustomModal("Confirm Logout", "Are you sure you want to log out?", true);
        if (confirmed) {
            // Clean up any active lobby state if user is in one
            if (currentLobbyId && activeLobbies[currentLobbyId]) {
                const lobby = activeLobbies[currentLobbyId];
                lobby.players = lobby.players.filter(p => p.id !== currentUser.id);
                // If no human players left, remove the lobby entirely
                if (lobby.players.filter(p => p.type === 'human').length === 0) {
                    delete activeLobbies[currentLobbyId];
                }
            }

            currentUser = null;
            userId = null;
            if (timer) clearInterval(timer); // Stop any active game timer

            // Reset UI to initial login state
            showSection(authContainer);
            logoutBtn.style.display = 'none';
            welcomeMessage.style.display = 'none';
            usernameInput.value = '';
            passwordInput.value = '';
            await showCustomModal("Logged Out", "You have been successfully logged out.");

            // Reset game-specific states
            players = [];
            currentLobbyType = '';
            currentLobbyId = '';
            isPlayerReady = false;
            currentQuestionIndex = 0;
            currentPlayerIndex = 0;
            timeLeft = 30;
            currentSoloStage = 0; // Reset this for the next login to ensure it loads from stored user data
            updateGlobalLeaderboard(); // Refresh global leaderboard (will show only bots if no humans logged in)
        }
    }

    /**
     * Updates the UI after successful login.
     */
    function handleSuccessfulAuth() {
        welcomeMessage.textContent = `Logged in as: ${currentUser.username} (ID: ${currentUser.id})`;
        welcomeMessage.style.display = 'block';
        logoutBtn.style.display = 'block';
        showSection(mainLobbyDashboard); // Show main lobby dashboard after login
        updateGlobalLeaderboard(); // Update global leaderboard on login
        // Inform the backend about the connected player for chat/leaderboard purposes
        socket.emit('player_connected', { username: currentUser.username, elo: currentUser.elo });
    }

    // --- Global Leaderboard (Uses in-memory 'users' data) ---
    /**
     * Updates the global leaderboard table using the in-memory 'users' data.
     */
    function updateGlobalLeaderboard() {
        globalLeaderboardBody.innerHTML = '';

        let globalPlayers = [];
        // Iterate through the in-memory users object
        for (const username in users) {
            const userData = users[username];
            globalPlayers.push({
                username: username,
                elo: userData.elo || 0,
                correctAnswers: userData.correctAnswers || 0,
                totalAnswers: userData.totalAnswers || 0
            });
        }

        // Sort by ELO (descending)
        globalPlayers.sort((a, b) => b.elo - a.elo);

        if (globalPlayers.length === 0) {
            const row = globalLeaderboardBody.insertRow();
            const cell = row.insertCell(0);
            cell.colSpan = 4;
            cell.textContent = 'No leaderboard data available.';
            cell.style.textAlign = 'center';
            return;
        }

        globalPlayers.forEach((player, index) => {
            const row = globalLeaderboardBody.insertRow();
            const accuracy = player.totalAnswers > 0 ? ((player.correctAnswers / player.totalAnswers) * 100).toFixed(0) : 0;
            row.innerHTML = `
                <td>${index + 1}</td>
                <td>${player.username}</td>
                <td>${player.elo}</td>
                <td>${accuracy}%</td>
            `;
        });
    }

    // --- Lobby Management Functions (In-Memory) ---

    /**
     * Generates a simple unique lobby ID.
     * @param {string} prefix A prefix for the lobby ID.
     * @returns {string} A unique lobby ID.
     */
    function generateLobbyId(prefix) {
        return `${prefix}-${Math.random().toString(36).substring(2, 8)}`;
    }

    /**
     * Opens the modal to create a new lobby.
     */
    function createNewLobby() {
        if (!currentUser) {
            showCustomModal("Error", "You must be logged in to create a lobby.");
            return;
        }
        createLobbyModal.style.display = 'flex';
        newLobbyNameInput.value = ''; // Clear previous input

        // Dynamically populate max players options based on currentLobbyType
        newLobbyMaxPlayersSelect.innerHTML = ''; // Clear existing options
        if (currentLobbyType === '1v1-fill-in-blanks') {
            const option = document.createElement('option');
            option.value = '2';
            option.textContent = '2 Players';
            newLobbyMaxPlayersSelect.appendChild(option);
            newLobbyMaxPlayersSelect.value = '2'; // Ensure it's selected
            newLobbyMaxPlayersSelect.disabled = true; // Disable selection for 1v1
        } else {
            // Default options for other game types (e.g., 4v4 Q&A)
            const options = [2, 3, 4];
            options.forEach(num => {
                const option = document.createElement('option');
                option.value = num;
                option.textContent = `${num} Players`;
                newLobbyMaxPlayersSelect.appendChild(option);
            });
            newLobbyMaxPlayersSelect.value = '2'; // Default to 2 players for other modes
            newLobbyMaxPlayersSelect.disabled = false; // Enable selection
        }
    }

    /**
     * Closes the create lobby modal.
     */
    function closeCreateLobbyModal() {
        createLobbyModal.style.display = 'none';
        newLobbyNameInput.value = '';
        // Reset max players select to default state (e.g., re-enable and show all options)
        newLobbyMaxPlayersSelect.innerHTML = `
            <option value="2">2 Players</option>
            <option value="3">3 Players</option>
            <option value="4">4 Players</option>
        `;
        newLobbyMaxPlayersSelect.value = '2';
        newLobbyMaxPlayersSelect.disabled = false;
    }

    /**
     * Confirms and creates a new lobby based on modal inputs.
     */
    async function confirmCreateLobby() {
        const lobbyName = newLobbyNameInput.value.trim();
        const maxPlayers = parseInt(newLobbyMaxPlayersSelect.value);

        if (!lobbyName) {
            await showCustomModal("Error", "Please enter a lobby name.");
            return;
        }

        const newLobbyId = generateLobbyId(currentLobbyType.replace('-', '_'));

        const initialPlayer = {
            id: currentUser.id,
            name: currentUser.username,
            isReady: false, // For casual lobbies, still require manual ready-up
            type: 'human',
            elo: currentUser.elo
        };

        const newLobby = {
            id: newLobbyId,
            name: lobbyName,
            type: currentLobbyType,
            players: [initialPlayer],
            maxPlayers: maxPlayers,
            gameStarted: false,
            chatMessages: []
        };

        // Add bots if maxPlayers > 1 for simulation purposes
        for (let i = 1; i < maxPlayers; i++) {
            newLobby.players.push({
                id: `bot_${newLobbyId}_${i}`,
                name: `Bot_${i}`,
                isReady: true, // Bots are always ready
                type: 'bot',
                elo: 1000 // Bots have a default ELO
            });
        }

        activeLobbies[newLobbyId] = newLobby;
        closeCreateLobbyModal();
        await joinLobby(newLobbyId); // Automatically join the newly created lobby
        // Removed: await showCustomModal("Lobby Created", `Lobby "${lobbyName}" created! ID: ${newLobbyId}`);
    }

    /**
     * Displays the list of available lobbies for a given game type.
     * This function is now primarily for casual lobbies.
     * @param {string} type The game mode type ('free-for-all-qna' or '1v1-fill-in-blanks').
     */
    function showLobbyList(type) {
        if (!currentUser) {
            showCustomModal("Error", "Please log in to view lobbies.");
            return;
        }

        currentLobbyType = type; // Set the current lobby type

        showSection(lobbyListContainer);
        lobbyListTitle.textContent = `Available ${type === 'free-for-all-qna' ? 'Free for All Q&A' : '1v1 Fill in the Blanks'} Lobbies`;
        renderLobbies();
    }

    /**
     * Initiates a ranked match by finding or creating a hidden lobby for the specified game type.
     * @param {string} gameType The specific ranked game type (e.g., 'ranked-free-for-all-qna', 'ranked-1v1-fill-in-blanks').
     */
    async function initiateRankedMatch(gameType) {
        if (!currentUser) {
            await showCustomModal("Error", "You must be logged in to join a ranked lobby.");
            return;
        }

        currentLobbyType = gameType; // Set the current lobby type to the ranked game type

        let foundLobby = null;
        // Try to find an existing ranked lobby that is not full and not started
        for (const lobbyId in activeLobbies) {
            const lobby = activeLobbies[lobbyId];
            if (lobby.type === gameType && lobby.players.length < lobby.maxPlayers && !lobby.gameStarted) {
                foundLobby = lobby;
                break;
            }
        }

        if (foundLobby) {
            // Removed: await showCustomModal("Match Found!", `Joining ranked lobby: ${foundLobby.name}`);
            await joinLobby(foundLobby.id);
        } else {
            // No suitable lobby found, create a new one
            const newLobbyId = generateLobbyId(gameType.replace(/-/g, '_')); // Use gameType for ID prefix
            let maxPlayers;
            let lobbyName;

            if (gameType === 'ranked-1v1-fill-in-blanks') {
                maxPlayers = 2;
                lobbyName = "Ranked 1v1 Match";
            } else if (gameType === 'ranked-free-for-all-qna') {
                maxPlayers = 4; // Assuming 4 players for ranked FFA
                lobbyName = "Ranked FFA Match";
            } else {
                console.error("Unknown ranked game type:", gameType);
                await showCustomModal("Error", "Invalid ranked game type selected.");
                return;
            }

            const initialPlayer = {
                id: currentUser.id,
                name: currentUser.username,
                isReady: true, // Auto ready-up for ranked lobbies
                type: 'human',
                elo: currentUser.elo
            };

            const newLobby = {
                id: newLobbyId,
                name: lobbyName,
                type: gameType, // Store the specific ranked game type
                players: [initialPlayer],
                maxPlayers: maxPlayers,
                gameStarted: false,
                chatMessages: []
            };

            // Add bots to fill the lobby
            for (let i = 1; i < maxPlayers; i++) {
                newLobby.players.push({
                    id: `bot_${newLobbyId}_${i}`,
                    name: `RankedBot_${i}`,
                    isReady: true,
                    type: 'bot',
                    elo: 1000
                });
            }

            activeLobbies[newLobbyId] = newLobby;
            // Removed: await showCustomModal("Lobby Created", `No match found. Created a new ranked lobby. ID: ${newLobbyId}`);
            await joinLobby(newLobbyId);
        }
    }


    /**
     * Renders the list of lobbies in the lobbies grid.
     */
    function renderLobbies() {
        lobbiesGrid.innerHTML = ''; // Clear existing lobbies

        // Only display lobbies that match the currentLobbyType and are not ranked
        const lobbiesToDisplay = Object.values(activeLobbies).filter(lobby =>
            lobby.type === currentLobbyType && !lobby.type.startsWith('ranked-')
        );

        if (lobbiesToDisplay.length === 0) {
            lobbiesGrid.innerHTML = '<p style="color: #ccc; text-align: center;">No lobbies found. Create one!</p>';
            return;
        }

        lobbiesToDisplay.forEach((lobby) => {
            const playerCount = lobby.players ? lobby.players.length : 0;
            const maxPlayers = lobby.maxPlayers;
            const isFull = playerCount >= maxPlayers;

            const lobbyCard = document.createElement('div');
            lobbyCard.className = `lobby-card ${isFull || lobby.gameStarted ? 'full' : ''}`;
            lobbyCard.innerHTML = `
                <h3>${lobby.name} <span style="font-size: 0.8em; opacity: 0.7;">(ID: ${lobby.id})</span></h3>
                <p>Players: ${playerCount}/${maxPlayers}</p>
                <p>Status: ${lobby.gameStarted ? 'In Game' : 'Waiting'}</p>
                <button class="join-btn primary-btn" data-lobby-id="${lobby.id}" ${isFull || lobby.gameStarted ? 'disabled' : ''}>
                    ${isFull ? 'Full' : (lobby.gameStarted ? 'In Game' : 'Join')}
                </button>
            `;
            lobbyCard.querySelector('.join-btn').addEventListener('click', () => joinLobby(lobby.id));
            lobbiesGrid.appendChild(lobbyCard);
        });
    }

    /**
     * Joins an existing lobby.
     * @param {string} lobbyIdToJoin The ID of the lobby to join.
     */
    async function joinLobby(lobbyIdToJoin) {
        if (!currentUser) {
            await showCustomModal("Error", "You must be logged in to join a lobby.");
            return;
        }

        const lobby = activeLobbies[lobbyIdToJoin];
        if (!lobby) {
            await showCustomModal("Error", "Lobby does not exist.");
            return;
        }

        currentLobbyId = lobbyIdToJoin;
        let currentPlayers = lobby.players || [];

        // Check if player is already in this lobby
        if (currentPlayers.some(p => p.id === currentUser.id)) {
            // Player is already in this lobby, just re-enter view
            // No modal needed here either
        } else {
            // If lobby is full, prevent joining
            if (currentPlayers.length >= lobby.maxPlayers) {
                await showCustomModal("Error", "Lobby is full.");
                currentLobbyId = ''; // Clear lobby id if cannot join
                return;
            }

            // Add current user to the lobby
            const playerToAdd = {
                id: currentUser.id,
                name: currentUser.username,
                isReady: lobby.type.startsWith('ranked-') ? true : false, // Auto ready for ranked, manual for casual
                type: 'human',
                elo: currentUser.elo
            };
            currentPlayers.push(playerToAdd);
            lobby.players = currentPlayers; // Update in-memory lobby
        }

        // Update local players array from the lobby
        players = [...lobby.players];
        const currentPlayerInLobby = players.find(p => p.id === currentUser.id);
        isPlayerReady = currentPlayerInLobby ? currentPlayerInLobby.isReady : false;

        showSection(singleLobbyView);
        currentLobbyTitle.textContent = `Lobby: ${lobby.name}`;
        displayLobbyId.textContent = currentLobbyId;
        displayPlayerCount.textContent = players.length;
        displayMaxPlayers.textContent = lobby.maxPlayers;
        displayLobbyStatus.textContent = lobby.gameStarted ? 'In Game' : 'Waiting';

        updateReadyButtonState();
        renderLobbyPlayers();
        updateStartGameButtonState();

        // Ensure correct chatbox is visible based on the lobby type
        if (currentLobbyType.includes('qna')) { // Works for both casual and ranked FFA Q&A
            chatBox4v4.style.display = 'flex';
            renderChatMessages('4v4', lobby.chatMessages);
        } else if (currentLobbyType.includes('fill-in-blanks')) { // Works for both casual and ranked 1v1 fill-in-the-blanks
            chatBox1v1.style.display = 'flex';
            renderChatMessages('1v1', lobby.chatMessages);
        }
    }

    /**
     * Leaves the current lobby.
     */
    async function leaveLobby() {
        if (!currentLobbyId || !currentUser) {
            return; // Not in a lobby
        }

        const confirmed = await showCustomModal("Confirm Leave", "Are you sure you want to leave this lobby?", true);
        if (!confirmed) {
            return;
        }

        const lobby = activeLobbies[currentLobbyId];
        if (lobby) {
            lobby.players = lobby.players.filter(p => p.id !== currentUser.id);
            // If no human players left, remove the lobby entirely
            if (lobby.players.filter(p => p.type === 'human').length === 0) {
                delete activeLobbies[currentLobbyId];
            }
        }
        leaveLobbyStateCleanUp();
        await showCustomModal("Lobby Left", "You have left the lobby.");
    }

    /**
     * Cleans up state after leaving a lobby.
     */
    function leaveLobbyStateCleanUp() {
        currentLobbyId = '';
        players = [];
        isPlayerReady = false;
        // If leaving a ranked lobby, go back to ranked game mode selection
        if (currentLobbyType.startsWith('ranked-')) {
            showSection(rankedGameModeSelection);
        } else {
            showSection(lobbyListContainer); // Go back to the list of lobbies for the current type
            renderLobbies(); // Re-render lobbies to reflect changes
        }
        currentLobbyType = ''; // Clear lobby type after leaving
    }

    /**
     * Toggles the current user's ready status in the lobby.
     */
    function toggleReady() {
        if (!currentLobbyId || !currentUser) {
            showCustomModal("Error", "Not in a lobby.");
            return;
        }

        const lobby = activeLobbies[currentLobbyId];
        if (lobby) {
            const playerIndex = lobby.players.findIndex(p => p.id === currentUser.id);
            if (playerIndex !== -1) {
                lobby.players[playerIndex].isReady = !lobby.players[playerIndex].isReady;
                isPlayerReady = lobby.players[playerIndex].isReady; // Update local state
                players = [...lobby.players]; // Update local players array
                updateReadyButtonState();
                renderLobbyPlayers(); // Re-render players to reflect ready status
                updateStartGameButtonState(); // Update start button based on new ready status
            }
        }
    }

    /**
     * Updates the text and styling of the "Ready Up!" button.
     */
    function updateReadyButtonState() {
        readyToggleBtn.textContent = isPlayerReady ? 'Unready' : 'Ready Up!';
        readyToggleBtn.style.backgroundColor = isPlayerReady ? '#e08000' : '#008000'; // Orange for unready, Green for ready
        readyToggleBtn.style.borderColor = isPlayerReady ? '#ff9900' : '#00ff00';
        readyToggleBtn.style.boxShadow = isPlayerReady ? '0 0 10px #ff9900' : '0 0 10px #00ff00';
        // Disable ready button if in a ranked lobby (since it's auto-ready)
        readyToggleBtn.disabled = currentLobbyType.startsWith('ranked-');
    }

    /**
     * Renders the list of players within the single lobby view.
     */
    function renderLobbyPlayers() {
        lobbyPlayersDisplay.innerHTML = ''; // Clear current players

        players.forEach(p => {
            const playerCard = document.createElement('div');
            playerCard.className = 'lobby-card'; // Reuse lobby card style for players
            playerCard.style.cursor = 'default';
            playerCard.style.minHeight = 'auto';
            playerCard.style.padding = '15px';

            playerCard.innerHTML = `
                <h3>${p.name} ${p.id === currentUser.id ? "(You)" : ""} ${p.type === 'bot' ? "(Bot)" : ""}</h3>
                <p>ELO: ${p.elo}</p>
                <p>Status: <span class="player-status ${p.isReady ? 'ready' : 'not-ready'}">${p.isReady ? 'Ready' : 'Not Ready'}</span></p>
            `;
            lobbyPlayersDisplay.appendChild(playerCard);
        });
    }

    /**
     * Updates the enabled/disabled state of the "Start Game" button.
     */
    function updateStartGameButtonState() {
        const lobby = activeLobbies[currentLobbyId];

        if (!lobby) {
            startGameButton.disabled = true;
            return;
        }

        // Only the first player (host) can start the game in this basic implementation
        const isHost = lobby.players[0] && lobby.players[0].id === currentUser.id;
        const allPlayersReady = lobby.players.length > 0 && lobby.players.every(p => p.isReady);
        const hasMinPlayers = lobby.players.length >= 2; // Example: require at least 2 players

        startGameButton.disabled = !(isHost && allPlayersReady && hasMinPlayers);

        if (isHost && allPlayersReady && hasMinPlayers) {
            startGameButton.title = "All players are ready! Click to start.";
        } else if (isHost) {
            let tooltip = "You are the host. ";
            if (!hasMinPlayers) tooltip += "Need at least 2 players. ";
            if (!allPlayersReady) tooltip += "Waiting for all players to be ready.";
            startGameButton.title = tooltip;
        } else {
            startGameButton.title = "Only the host can start the game when all players are ready.";
        }
    }

    /**
     * Initiates the game for the current lobby.
     */
    async function startGame() {
        if (!currentLobbyId || !currentUser) {
            showCustomModal("Error", "Not in a lobby.");
            return;
        }

        const confirmed = await showCustomModal("Confirm Game Start", "Are you sure you want to start the game?", true);
        if (!confirmed) {
            return;
        }

        const lobby = activeLobbies[currentLobbyId];
        if (!lobby) {
            showCustomModal("Error", "Lobby not found to start game.");
            return;
        }

        // Basic host check (first player in the lobby)
        const isHost = lobby.players[0] && lobby.players[0].id === currentUser.id;
        if (!isHost) {
            showCustomModal("Permission Denied", "Only the lobby host can start the game.");
            return;
        }

        // Check if all players are ready and there are enough players
        const allPlayersReady = lobby.players.length > 0 && lobby.players.every(p => p.isReady);
        const hasMinPlayers = lobby.players.length >= 2;

        if (!hasMinPlayers) {
            showCustomModal("Cannot Start", "Need at least 2 players to start the game.");
            return;
        }

        if (!allPlayersReady) {
            showCustomModal("Cannot Start", "Not all players are ready.");
            return;
            }

        lobby.gameStarted = true;
        await showCustomModal("Game Started!", "The game is commencing!");
        startGameUI(lobby.type); // Transition to game UI
    }

    /**
     * Transitions the UI to the game screen based on game type.
     * @param {string} gameType The type of game to start ('free-for-all-qna', '1v1-fill-in-blanks', 'ranked-1v1-fill-in-blanks', 'ranked-free-for-all-qna').
     */
    function startGameUI(gameType) {
        showSection(gameUI); // Show common game UI wrapper
        mainContentWrapper.style.display = 'flex'; // Ensure wrapper is visible

        // Hide all specific game layouts initially
        fourVFourQnALayout.style.display = 'none';
        oneVOneFillInBlanksLayout.style.display = 'none';

        if (gameType.includes('qna')) { // Works for both casual and ranked FFA Q&A
            fourVFourQnALayout.style.display = 'flex';
            chatBox4v4.style.display = 'flex'; // Explicitly show 4v4 chat
            initializeGameRound(gameType);
        } else if (gameType.includes('fill-in-blanks')) { // Works for both casual and ranked 1v1 fill-in-the-blanks
            oneVOneFillInBlanksLayout.style.display = 'flex';
            chatBox1v1.style.display = 'flex'; // Explicitly show 1v1 chat
            initializeGameRound(gameType);
        }
    }

    /**
     * Leaves the current game and returns to the single lobby view.
     */
    async function leaveGame() {
        const confirmed = await showCustomModal("Confirm Exit Game", "Are you sure you want to exit the current game and return to lobbies?", true);
        if (!confirmed) {
            return;
        }
        if (timer) clearInterval(timer);

        // Reset game UI elements
        gameTimerDisplay.textContent = '30';
        answerInput4v4.value = '';
        answerInput4v4.disabled = false;
        submitAnswerBtn4v4.style.display = 'block';
        replayButton.style.display = 'none';
        playerCircleDiv.innerHTML = ''; // Clear players from 4v4 view
        questionBox1v1Player1.style.display = 'none';
        questionBox1v1Player2.style.display = 'none';


        const lobby = activeLobbies[currentLobbyId];
        if (lobby) {
            lobby.gameStarted = false; // Reset game started flag
            // Reset player states for the lobby view
            lobby.players = lobby.players.map(p => ({
                ...p,
                lives: 3,
                correctAnswers: 0,
                totalAnswers: 0,
                currentRoundScore: 0,
                isReady: p.type === 'human' ? (lobby.type.startsWith('ranked-') ? true : false) : true // Human ready state depends on lobby type, bots stay ready
            }));
            players = [...lobby.players]; // Update local players array

            // Update current user's ready status in the lobby
            const currentPlayerInLobby = players.find(p => p.id === currentUser.id);
            isPlayerReady = currentPlayerInLobby ? currentPlayerInLobby.isReady : false;

            showSection(singleLobbyView); // Go back to single lobby view
            currentLobbyTitle.textContent = `Lobby: ${lobby.name}`;
            displayLobbyId.textContent = currentLobbyId;
            displayPlayerCount.textContent = players.length;
            displayMaxPlayers.textContent = lobby.maxPlayers;
            displayLobbyStatus.textContent = lobby.gameStarted ? 'In Game' : 'Waiting';

            updateReadyButtonState();
            renderLobbyPlayers();
            updateStartGameButtonState();
            // Re-render chat for the specific lobby
            if (lobby.type.includes('qna')) {
                chatBox4v4.style.display = 'flex';
                renderChatMessages('4v4', lobby.chatMessages);
            } else if (lobby.type.includes('fill-in-blanks')) {
                chatBox1v1.style.display = 'flex';
                renderChatMessages('1v1', lobby.chatMessages);
            }
        } else {
            // If lobby no longer exists (e.g., deleted due to no human players)
            leaveLobbyStateCleanUp(); // Go back to lobby list
            showCustomModal("Lobby Ended", "The lobby has ended. Returning to lobby list.");
        }
    }

    /**
     * Leaves the solo challenge and returns to the game mode selection.
     */
    async function leaveSoloChallenge() {
        const confirmed = await showCustomModal("Confirm Exit Solo Challenge", "Are you sure you want to exit the solo challenge and return to mode selection?", true);
        if (!confirmed) {
            return;
        }
        showSection(gameModeSelection);
        // Save current solo stage to in-memory user data
        if (currentUser) {
            users[currentUser.username].soloStage = currentUser.soloStage;
        }
        currentSoloStage = currentUser ? currentUser.soloStage : 0; // Reset solo stage to last saved
    }

    /**
     * Returns from lobby list to game mode selection (casual or ranked).
     */
    function backToModeSelection() {
        // Determine which mode selection to go back to based on currentLobbyType
        if (currentLobbyType.startsWith('ranked-')) {
            showSection(rankedGameModeSelection);
        } else {
            showSection(gameModeSelection);
        }
        currentLobbyId = '';
        currentLobbyType = ''; // Clear currentLobbyType
        players = [];
        isPlayerReady = false;
    }

    /**
     * Returns from single lobby view to the lobby list.
     */
    function backToLobbiesList() {
        showSection(lobbyListContainer);
        currentLobbyId = '';
        isPlayerReady = false; // Reset ready status
        updateReadyButtonState(); // Reset button text
        renderLobbies(); // Refresh lobby list
    }

    /**
     * Returns from game mode selection (casual or ranked) to the main lobby dashboard.
     */
    function backToDashboard() {
        showSection(mainLobbyDashboard);
        currentLobbyType = ''; // Clear current lobby type
    }

    // --- In-Game Functions (Q&A / Fill-in-the-blanks) ---

    /**
     * Initializes a new game round for multiplayer modes.
     * @param {string} gameType The type of game ('free-for-all-qna', '1v1-fill-in-blanks', 'ranked-1v1-fill-in-blanks', 'ranked-free-for-all-qna').
     */
    function initializeGameRound(gameType) {
        // Determine which set of questions to use based on the gameType
        if (gameType.includes('qna')) {
            questions = [...originalQuestions];
        } else if (gameType.includes('fill-in-blanks')) {
            questions = [...fillInBlanksQuestions];
        } else {
            console.error("Unknown game type for question selection:", gameType);
            questions = [...originalQuestions]; // Default to original questions
        }
        questions.sort(() => Math.random() - 0.5); // Shuffle questions

        // Reset player lives and scores for the game round from the lobby's players
        const lobby = activeLobbies[currentLobbyId];
        if (lobby) {
            players = lobby.players.map(p => ({
                ...p,
                lives: 3, // Default starting lives
                correctAnswers: 0,
                totalAnswers: 0,
                currentRoundScore: 0
            }));
        } else {
            console.error("Lobby not found during game round initialization.");
            return;
        }

        currentQuestionIndex = 0;
        currentPlayerIndex = 0; // Start with the first player in the shuffled list
        updateGameUI();
        startTimer();

        // Focus the correct answer input based on game type and current player
        if (gameType.includes('qna')) { // Works for both casual and ranked FFA Q&A
            answerInput4v4.value = '';
            answerInput4v4.focus();
        } else if (gameType.includes('fill-in-blanks')) { // Works for both casual and ranked 1v1 fill-in-the-blanks
            const currentPlayer = players[currentPlayerIndex];
            if (currentPlayer.id === currentUser.id) {
                answerInput1v1Player1.value = '';
                answerInput1v1Player1.focus();
            } else {
                answerInput1v1Player1.value = '';
                answerInput1v1Player1.disabled = true; // Disable player's input if it's bot's turn
            }
        }
    }

    /**
     * Updates the game UI elements based on the current game state.
     */
    function updateGameUI() {
        // Hide all specific question boxes initially
        questionBox4v4.style.display = 'none';
        questionBox1v1Player1.style.display = 'none';
        questionBox1v1Player2.style.display = 'none';

        const currentPlayer = players[currentPlayerIndex];

        if (currentLobbyType.includes('qna')) { // Works for both casual and ranked FFA Q&A
            questionBox4v4.style.display = 'block';
            question4v4Display.textContent = questions[currentQuestionIndex].q;
            updatePlayerPositions4v4(); // For 4v4, update circular positions
            answerInput4v4.disabled = false;
            submitAnswerBtn4v4.style.display = 'block';
        } else if (currentLobbyType.includes('fill-in-blanks')) { // Works for both casual and ranked 1v1 fill-in-the-blanks
            render1v1Players(); // For 1v1, update side-by-side player panels

            if (currentPlayer.id === currentUser.id) { // If it's the current user's turn
                player1Panel.classList.add('active-player-turn'); // Highlight current player's panel
                questionBox1v1Player1.style.display = 'block';
                question1v1Player1.textContent = questions[currentQuestionIndex].q;
                answerInput1v1Player1.disabled = false;
                answerInput1v1Player1.focus();
                submitAnswerBtn1v1Player1.style.display = 'block';
            } else { // If it's the bot's turn
                player2Panel.classList.add('active-player-turn'); // Highlight bot's panel
                questionBox1v1Player2.style.display = 'block';
                question1v1Player2.textContent = questions[currentQuestionIndex].q;
                answerInput1v1Player1.disabled = true; // Disable human player input
                submitAnswerBtn1v1Player1.style.display = 'none';
                handleBotAnswer(); // Trigger bot's turn
            }
        }

        updateLeaderboard(); // Update current round leaderboard
    }

    /**
     * Starts the countdown timer for the current question.
     */
    function startTimer() {
        if (timer) clearInterval(timer);
        timeLeft = 30; // Reset time for each question
        gameTimerDisplay.textContent = timeLeft;
        timer = setInterval(() => {
            timeLeft--;
            gameTimerDisplay.textContent = timeLeft;
            if (timeLeft <= 0) {
                clearInterval(timer);
                showCustomModal('Time Up!', `${players[currentPlayerIndex].name} ran out of time!`);
                processAnswer(false); // Time's up, process as wrong answer
            }
        }, 1000);
    }

    /**
     * Handles the submission of an answer by the user.
     */
    function submitAnswer() {
        clearInterval(timer); // Stop timer immediately

        let answerInput;
        let correctAnswer;

        if (currentLobbyType.includes('qna')) { // Works for both casual and ranked FFA Q&A
            answerInput = answerInput4v4;
            correctAnswer = questions[currentQuestionIndex].a;
            answerInput4v4.disabled = true;
            submitAnswerBtn4v4.style.display = 'none';
        } else if (currentLobbyType.includes('fill-in-blanks')) { // Works for both casual and ranked 1v1 fill-in-the-blanks
            const currentPlayer = players[currentPlayerIndex];
            if (currentPlayer.id === currentUser.id) {
                answerInput = answerInput1v1Player1;
                correctAnswer = questions[currentQuestionIndex].a;
                answerInput1v1Player1.disabled = true;
                submitAnswerBtn1v1Player1.style.display = 'none';
            } else {
                showCustomModal("Error", "It's not your turn!");
                return;
            }
        }

        const userAnswer = answerInput.value.trim();
        const isCorrect = userAnswer.toLowerCase() === correctAnswer.toLowerCase();
        processAnswer(isCorrect);
        answerInput.value = ''; // Clear input for next question
    }

    /**
     * Simulates a bot's answer for their turn.
     */
    async function handleBotAnswer() {
        const botSpeed = 2000; // Bot answers after 2 seconds
        if (timer) clearInterval(timer); // Pause human timer for bot turn
        gameTimerDisplay.textContent = "BOT THINKING...";

        setTimeout(() => {
            // Bot always gets it right for simplicity
            processAnswer(true); // Bot answers correctly
        }, botSpeed);
    }

    /**
     * Processes an answer, updates player stats, and advances the game.
     * @param {boolean} isCorrect True if the answer was correct, false otherwise.
     */
    async function processAnswer(isCorrect) {
        if (timer) clearInterval(timer);

        const currentPlayer = players[currentPlayerIndex];

        // Update player stats (in-memory for current game round)
        currentPlayer.totalAnswers++;
        if (isCorrect) {
            currentPlayer.correctAnswers++;
            currentPlayer.currentRoundScore += timeLeft * 10; // Score based on remaining time
            await showCustomModal("Correct!", `Well done, ${currentPlayer.name}!`);
        } else {
            currentPlayer.lives--;
            currentPlayer.currentRoundScore -= 50; // Penalty for wrong answer
            await showCustomModal("Wrong!", `Incorrect. The answer was "${questions[currentQuestionIndex].a}". ${currentPlayer.name} loses a life.`);
        }

        // Update current user's ELO and overall stats (in-memory 'users' object)
        if (currentPlayer.type === 'human' && currentPlayer.id === currentUser.id) {
            currentUser.correctAnswers = currentPlayer.correctAnswers;
            currentUser.totalAnswers = currentPlayer.totalAnswers;
            if (isCorrect) {
                currentUser.elo += 10; // +10 ELO for correct
            } else {
                currentUser.elo -= 5; // -5 ELO for incorrect
            }
            if (currentUser.elo < 0) currentUser.elo = 0; // Prevent negative ELO

            // Update the global in-memory users object
            users[currentUser.username].correctAnswers = currentUser.correctAnswers;
            users[currentUser.username].totalAnswers = currentUser.totalAnswers;
            users[currentUser.username].elo = currentUser.elo;

            // Update the welcome message in the header to reflect new ELO
            welcomeMessage.textContent = `Logged in as: ${currentUser.username} (ID: ${currentUser.id}) ELO: ${currentUser.elo}`;

            // Send ELO update to backend for global leaderboard persistence
            try {
                await fetch(`${BACKEND_URL}/api/update-user-data`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ username: currentUser.username, soloStage: currentUser.soloStage, elo: currentUser.elo })
                });
                socket.emit('request_global_leaderboard'); // Request fresh leaderboard after ELO changes
            } catch (error) {
                console.error("Failed to update user data on backend:", error);
            }

        } else if (currentPlayer.type === 'bot') {
            // Update bot's ELO (for display purposes, doesn't affect global leaderboard as bots aren't "users")
            if (isCorrect) {
                currentPlayer.elo += 5;
            } else {
                currentPlayer.elo = Math.max(0, currentPlayer.elo - 2);
            }
        }

        // Apply visual feedback
        if (currentLobbyType.includes('qna')) { // Works for both casual and ranked FFA Q&A
            const playerElement = document.querySelector(`.player[data-player-id="${currentPlayer.id}"] .name`);
            if (playerElement) {
                playerElement.classList.remove('active');
                playerElement.classList.add(isCorrect ? 'correct' : 'wrong');
                setTimeout(() => {
                    playerElement.classList.remove('correct', 'wrong');
                }, 1000); // Remove feedback after 1 second
            }
        } else if (currentLobbyType.includes('fill-in-blanks')) { // Works for both casual and ranked 1v1 fill-in-the-blanks
            player1Panel.classList.remove('active-player-turn');
            player2Panel.classList.remove('active-player-turn');
        }

        // Check for game over or next round
        if (currentPlayer.lives <= 0) {
            await showCustomModal("Player Eliminated", `${currentPlayer.name} has been eliminated!`);
            players = players.filter(p => p.id !== currentPlayer.id);
            if (players.length <= 1) { // If only one or zero players remaining
                endGame();
                return;
            }
            // Adjust currentPlayerIndex if the current player was removed and it was the last one
            if (currentPlayerIndex >= players.length) {
                currentPlayerIndex = 0;
            }
        }

        // Move to next player
        currentPlayerIndex = (currentPlayerIndex + 1) % players.length;

        // Move to next question after each answer
        currentQuestionIndex++;
        if (currentQuestionIndex >= questions.length) {
            currentQuestionIndex = 0; // Loop questions for continuous play in simulation
        }

        updateGameUI(); // Update UI for the next turn
        startTimer(); // Start timer for the next turn
        updateGlobalLeaderboard(); // Update global leaderboard after each answer for visibility
    }

    /**
     * Ends the current game round.
     */
    async function endGame() {
        if (timer) clearInterval(timer);
        await showCustomModal("Game Over!", "The game has ended. Check the leaderboard for results!");
        replayButton.style.display = 'block';
        // Hide all specific question boxes
        questionBox4v4.style.display = 'none';
        questionBox1v1Player1.style.display = 'none';
        questionBox1v1Player2.style.display = 'none';
    }

    /**
     * Resets the game state and starts a new round.
     */
    function replayGame() {
        replayButton.style.display = 'none';
        // Reset player states in the active lobby for replay
        const lobby = activeLobbies[currentLobbyId];
        if (lobby) {
            lobby.players = lobby.players.map(p => ({
                ...p,
                lives: 3,
                correctAnswers: 0,
                totalAnswers: 0,
                currentRoundScore: 0,
                isReady: p.type === 'human' ? (lobby.type.startsWith('ranked-') ? true : false) : true // Human ready state depends on lobby type, bots stay ready
            }));
            players = [...lobby.players]; // Update local player array
            isPlayerReady = lobby.type.startsWith('ranked-') ? true : false; // Current user ready state based on lobby type
            updateReadyButtonState(); // Update ready button state
            updateStartGameButtonState(); // Update start button status
        }
        // Redirect back to single lobby view, as replay starts a new "round" but not a new game entirely
        showSection(singleLobbyView);
    }

    /**
     * Renders player positions for the 4v4 Q&A layout.
     */
    function updatePlayerPositions4v4() {
        playerCircleDiv.innerHTML = ''; // Clear existing players

        if (players.length === 0) return;

        const radius = playerCircleDiv.offsetWidth / 2 - 70; // Adjust radius for player size
        const centerX = playerCircleDiv.offsetWidth / 2;
        const centerY = playerCircleDiv.offsetHeight / 2;

        players.forEach((player, index) => {
            const angle = (index / players.length) * 2 * Math.PI;
            const x = centerX + radius * Math.cos(angle);
            const y = centerY + radius * Math.sin(angle);

            const playerDiv = document.createElement('div');
            playerDiv.className = 'player';
            playerDiv.setAttribute('data-player-id', player.id);
            playerDiv.style.left = `${x}px`;
            playerDiv.style.top = `${y}px`;
            playerDiv.innerHTML = `
                <div class="name ${player.id === players[currentPlayerIndex].id ? 'active' : ''}">${player.name}</div>
                <div class="lives">Lives: ${player.lives}</div>
            `;
            playerCircleDiv.appendChild(playerDiv);
        });
    }

    /**
     * Renders player panels for the 1v1 Fill-in-the-Blanks layout.
     */
    function render1v1Players() {
        // Reset active player highlights and question boxes
        player1Panel.classList.remove('active-player-turn');
        player2Panel.classList.remove('active-player-turn');
        questionBox1v1Player1.style.display = 'none';
        questionBox1v1Player2.style.display = 'none';


        const player1 = players.find(p => p.id === currentUser.id); // Assuming player 1 is always the human
        const player2 = players.find(p => p.id !== currentUser.id); // Assuming player 2 is the opponent/bot

        if (!player1 || !player2) {
            console.error("Missing players for 1v1 rendering.");
            return;
        }

        // Render player 1 (human) details
        player1Name.textContent = player1.name;
        player1YouTag.textContent = "(You)";
        player1Lives.textContent = player1.lives;
        player1Elo.textContent = player1.elo;

        // Render player 2 (opponent/bot) details
        player2Name.textContent = player2.name;
        player2YouTag.textContent = player2.type === 'bot' ? "(Bot)" : "";
        player2Lives.textContent = player2.lives;
        player2Elo.textContent = player2.elo;

        // Highlight active player
        const currentPlayerTurn = players[currentPlayerIndex];
        if (currentPlayerTurn.id === player1.id) {
            player1Panel.classList.add('active-player-turn');
        } else if (currentPlayerTurn.id === player2.id) {
            player2Panel.classList.add('active-player-turn');
        }
    }

    /**
     * Updates the current round leaderboard.
     */
    function updateLeaderboard() {
        leaderboardBody.innerHTML = '';

        // Sort players by currentRoundScore, then lives, then correctAnswers
        const sortedPlayers = [...players].sort((a, b) => {
            if (b.currentRoundScore !== a.currentRoundScore) {
                return b.currentRoundScore - a.currentRoundScore;
            }
            if (b.lives !== a.lives) {
                return b.lives - a.lives;
            }
            return b.correctAnswers - a.correctAnswers;
        });

        sortedPlayers.forEach((player, index) => {
            const row = leaderboardBody.insertRow();
            const accuracy = player.totalAnswers > 0 ? ((player.correctAnswers / player.totalAnswers) * 100).toFixed(0) : 0;
            row.innerHTML = `
                <td>${index + 1}</td>
                <td>${player.name}</td>
                <td>${player.elo}</td>
                <td>${accuracy}%</td>
            `;
        });
    }

    // --- Solo Challenge Logic ---

    /**
     * Initiates and displays the solo coding challenge UI.
     */
    function selectSoloChallengeMode() {
        if (!currentUser) {
            showCustomModal("Error", "Please log in to start a challenge.");
            return;
        }
        currentLobbyType = 'solo-coding-challenge';
        showSection(soloChallengeUI);
        // Load the current solo stage for the user from their in-memory data
        currentSoloStage = users[currentUser.username] ? users[currentUser.username].soloStage : 0;
        loadSoloChallenge();
    }

    /**
     * Loads and displays a specific solo challenge stage.
     */
    async function loadSoloChallenge() {
        const stageData = soloChallenges[currentSoloStage];
        if (!stageData) {
            await showCustomModal("Congratulations!", "You have completed all solo challenges!");
            soloProblemDescription.textContent = "All challenges completed!";
            soloCodeEditor.value = "";
            soloCodeEditor.disabled = true;
            soloPrevStageBtn.disabled = false;
            soloNextStageBtn.disabled = true;
            runCodeBtn.disabled = true;
            soloResult.textContent = 'All challenges completed.';
            return;
        }

        soloCurrentStageSpan.textContent = stageData.stage;
        soloProblemDescription.innerHTML = `<strong>Problem:</strong> ${stageData.problem}`;
        soloCodeEditor.value = stageData.initialCode;
        soloCodeEditor.disabled = false; // Ensure editor is enabled
        soloResult.textContent = ''; // Clear previous results

        // Update navigation buttons
        soloPrevStageBtn.disabled = currentSoloStage === 0;
        // User can only go to next stage if they've completed the current one (i.e., their saved soloStage is higher)
        soloNextStageBtn.disabled = (currentUser.soloStage <= currentSoloStage || currentSoloStage >= soloChallenges.length - 1);
        runCodeBtn.disabled = false; // Enable run button
    }

    /**
     * Navigates to the previous solo challenge stage.
     */
    function previousSoloStage() {
        if (currentSoloStage > 0) {
            currentSoloStage--;
            currentUser.soloStage = currentSoloStage; // Update currentUser and users map
            users[currentUser.username].soloStage = currentUser.soloStage;
            loadSoloChallenge();
        }
    }

    /**
     * Navigates to the next solo challenge stage.
     */
    function nextSoloStage() {
        // Allow advancing only if the user has completed the current stage
        if (currentSoloStage < currentUser.soloStage && currentSoloStage < soloChallenges.length - 1) {
            currentSoloStage++;
            currentUser.soloStage = currentSoloStage; // Update currentUser and users map
            users[currentUser.username].soloStage = currentUser.soloStage;
            loadSoloChallenge();
        } else {
            showCustomModal("Information", "Complete the current stage before moving to the next!");
        }
    }

    /**
     * Submits the user's C++ code for evaluation by the Gemini API.
     */
    async function submitSoloCode() {
        const code = soloCodeEditor.value;
        const stageData = soloChallenges[currentSoloStage];

        if (!stageData) {
            soloResult.textContent = 'Error: No challenge data found.';
            return;
        }
        if (!currentUser) {
            showCustomModal('Error', 'You must be logged in to submit code.');
            return;
        }

        soloResult.textContent = ''; // Clear previous result
        soloLoadingIndicator.style.display = 'block';
        runCodeBtn.disabled = true; // Disable button while running
        soloCodeEditor.disabled = true; // Disable editor while evaluating

        try {
            const payload = {
                contents: [
                    {
                        role: "user",
                        parts: [
                            { text: `You are a C++ code evaluator. Your task is to analyze a user's C++ code and determine if it correctly solves a given problem, specifically by checking if its simulated output matches the expected output.

Problem Description: "${stageData.problem}"
User's Code:
\`\`\`cpp
${code}
\`\`\`
Expected Output: "${stageData.expectedOutput}"

Based on a simulated compilation and execution of the user's code, provide a concise evaluation.
Your response should clearly state:
1. "Correct!" if the user's code is logically sound and its simulated output exactly matches the Expected Output.
2. If the code is incorrect or the simulated output does not match, provide "Incorrect." followed by a brief, helpful explanation of the discrepancy or a hint on what might be wrong, without giving away the full solution. Focus on output mismatches or common C++ errors (e.g., syntax, logic leading to wrong output).

Example of a correct response: "Correct!"
Example of an incorrect response: "Incorrect. Your code printed 'Hello' but the expected output was 'Hello, World!'. Check your string literal."
Example for a logical error: "Incorrect. Your code calculates the sum incorrectly. Review the loop condition or the summation logic."
Example for a syntax error: "Incorrect. There appears to be a syntax error in your code, specifically missing a semicolon on line X or an unclosed bracket."
` }
                        ]
                    }
                ]
            };

            const response = await fetch(API_URL, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(payload),
            });

            const result = await response.json();
            if (result.candidates && result.candidates.length > 0 && result.candidates[0].content && result.candidates[0].content.parts && result.candidates[0].content.parts.length > 0) {
                const geminiResponse = result.candidates[0].content.parts[0].text;
                soloResult.textContent = geminiResponse;

                // Check for "Correct!" in the response
                if (geminiResponse.includes("Correct!")) {
                    await showCustomModal("Success", `Stage ${stageData.stage} Complete!`);
                    // Only advance soloStage if they completed the current highest stage
                    if (currentUser.soloStage === stageData.stage) {
                        currentUser.soloStage++; // Advance user's overall progress
                        currentUser.elo += 75; // Award ELO for solo completion

                        // Update the global in-memory users object
                        users[currentUser.username].soloStage = currentUser.soloStage;
                        users[currentUser.username].elo = currentUser.elo;

                        // Update the welcome message in the header to reflect new ELO
                        welcomeMessage.textContent = `Logged in as: ${currentUser.username} (ID: ${currentUser.id}) ELO: ${currentUser.elo}`;

                        // Send updated soloStage and ELO to the backend for global leaderboard persistence
                        try {
                            await fetch(`${BACKEND_URL}/api/update-user-data`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ username: currentUser.username, soloStage: currentUser.soloStage, elo: currentUser.elo })
                            });
                            socket.emit('request_global_leaderboard'); // Request fresh leaderboard
                        } catch (error) {
                            console.error("Failed to update user data on backend:", error);
                        }
                    } else {
                        await showCustomModal("Information", "You already completed this stage before!");
                    }
                    // Automatically load next stage if successful (and if there is one)
                    loadSoloChallenge();
                } else {
                    await showCustomModal("Try Again", "Your code needs some adjustments. Check the evaluation for hints.");
                }
            } else {
                soloResult.textContent = 'Failed to get evaluation from AI.';
                await showCustomModal("Error", "Failed to get evaluation from AI.");
            }
        } catch (error) {
            console.error("Error calling Gemini API:", error);
            soloResult.textContent = "An error occurred during evaluation.";
            await showCustomModal("Error", "Could not connect to the evaluation server or AI.");
        } finally {
            soloLoadingIndicator.style.display = 'none';
            runCodeBtn.disabled = false; // Re-enable button
            soloCodeEditor.disabled = false; // Re-enable editor
            // Re-evaluate next stage button state
            soloNextStageBtn.disabled = (currentUser.soloStage <= currentSoloStage || currentSoloStage >= soloChallenges.length - 1);
        }
    }

    // --- Chat Functions (In-Memory per Lobby) ---
    /**
     * Sends a chat message within the current lobby.
     * @param {string} chatType The type of chat ('general', '4v4', or '1v1') to determine which chat input/display to use.
     */
    async function sendMessage(chatType) {
        let chatInput;
        let chatMessagesDiv;
        let messagesArray;

        // Removed 'general' chat type handling
        if (chatType === '4v4') {
            chatInput = chatInput4v4;
            chatMessagesDiv = chatMessages4v4Div;
            const lobby = activeLobbies[currentLobbyId];
            messagesArray = lobby ? lobby.chatMessages : [];
        } else if (chatType === '1v1') {
            chatInput = chatInput1v1;
            chatMessagesDiv = chatMessages1v1Div;
            const lobby = activeLobbies[currentLobbyId];
            messagesArray = lobby ? lobby.chatMessages : [];
        } else {
            console.error("Unknown chat type for sendMessage:", chatType);
            await showCustomModal("Chat Error", "Invalid chat context.");
            return;
        }

        if (!currentUser) {
            await showCustomModal("Error", "You must be logged in to chat.");
            return;
        }

        if (!currentLobbyId) { 
            await showCustomModal("Error", "You must be in a lobby to chat in game modes.");
            return;
        }

        const messageText = chatInput.value.trim();

        if (messageText === '') {
            return;
        }

        // Add message to the correct in-memory array
        messagesArray.push({
            senderId: currentUser.id,
            senderName: currentUser.username,
            message: messageText,
            timestamp: new Date()
        });
        chatInput.value = ''; // Clear input field

        // Re-render chat messages for the specific chat box
        renderChatMessages(chatType, messagesArray);

        // Optionally, send to backend for global chat if desired (not implemented in this version)
        // socket.emit('chat message', { sender: currentUser.username, message: messageText });
    }

    /**
     * Removed: Renders general chat messages.
     * function renderGeneralChatMessages() { ... }
     */

    /**
     * Renders game-specific chat messages.
     * @param {string} layoutType The type of game layout ('4v4' or '1v1').
     * @param {Array<Object>} messages An array of message objects.
     */
    function renderChatMessages(layoutType, messages) {
        let chatMessagesDiv;
        if (layoutType === '4v4') {
            chatMessagesDiv = chatMessages4v4Div;
        }
        else if (layoutType === '1v1') {
            chatMessagesDiv = chatMessages1v1Div;
        } else {
            console.error("Unknown layout type for renderChatMessages:", layoutType);
            return;
        }

        chatMessagesDiv.innerHTML = ''; // Clear existing messages

        // Sort messages by timestamp (already sorted if pushed sequentially, but good practice)
        messages.sort((a, b) => a.timestamp.getTime() - b.timestamp.getTime());

        messages.forEach(msg => {
            const msgElement = document.createElement('p');
            const timestamp = msg.timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            msgElement.innerHTML = `<strong>[${timestamp}] ${msg.senderName}:</strong> ${msg.message}`;
            chatMessagesDiv.appendChild(msgElement);
        });
        chatMessagesDiv.scrollTop = chatMessagesDiv.scrollHeight; // Scroll to bottom
    }


    // --- Event Listeners ---
    document.addEventListener('DOMContentLoaded', () => {
        // Initial UI state: show auth container
        showSection(authContainer);

        // Authentication buttons
        authSubmitBtn.addEventListener('click', authAction);
        authSwitch.addEventListener('click', toggleAuthMode);
        logoutBtn.addEventListener('click', logout);

        // Main Lobby Dashboard buttons
        casualModeBtn.addEventListener('click', () => showSection(gameModeSelection));
        rankedModeBtn.addEventListener('click', () => showSection(rankedGameModeSelection)); // Modified to show ranked mode selection
        customModeBtn.addEventListener('click', () => showSection(gameModeSelection)); // Custom mode still goes to casual selection for now

        // Game Mode Selection buttons (Casual)
        document.getElementById('four-v-four-qna-mode').addEventListener('click', () => showLobbyList('free-for-all-qna'));
        document.getElementById('one-v-one-fill-in-blanks-mode').addEventListener('click', () => showLobbyList('1v1-fill-in-blanks'));
        document.getElementById('solo-coding-challenge-mode').addEventListener('click', selectSoloChallengeMode);
        
        // Game Mode Selection buttons (Ranked) - New
        document.getElementById('ranked-four-v-four-qna-mode').addEventListener('click', () => initiateRankedMatch('ranked-free-for-all-qna'));
        document.getElementById('ranked-one-v-one-fill-in-blanks-mode').addEventListener('click', () => initiateRankedMatch('ranked-1v1-fill-in-blanks'));

        // Back to Dashboard buttons (now multiple)
        backToDashboardBtns.forEach(btn => {
            btn.addEventListener('click', backToDashboard);
        });

        // Lobby List and Single Lobby View buttons
        document.querySelector('.back-to-mode-selection-btn').addEventListener('click', backToModeSelection);
        createNewLobbyBtn.addEventListener('click', createNewLobby);
        confirmCreateLobbyBtn.addEventListener('click', confirmCreateLobby);
        cancelCreateLobbyBtn.addEventListener('click', closeCreateLobbyModal);
        document.querySelector('.back-to-lobbies-btn').addEventListener('click', leaveLobby);
        readyToggleBtn.addEventListener('click', toggleReady);
        startGameButton.addEventListener('click', startGame);

        // In-Game Buttons (4v4)
        document.getElementById('backToLobbyBtn4v4').addEventListener('click', leaveGame);
        submitAnswerBtn4v4.addEventListener('click', submitAnswer);
        replayButton.addEventListener('click', replayGame);

        // In-Game Buttons (1v1)
        document.getElementById('backToLobbyBtn1v1').addEventListener('click', leaveGame);
        submitAnswerBtn1v1Player1.addEventListener('click', submitAnswer); // User's submit button
        submitAnswerBtn1v1Player2.addEventListener('click', submitAnswer); // Bot's submit button (will be disabled for user)

        // Solo Challenge buttons
        soloBackToLobbyBtn.addEventListener('click', leaveSoloChallenge);
        soloPrevStageBtn.addEventListener('click', previousSoloStage);
        soloNextStageBtn.addEventListener('click', nextSoloStage);
        runCodeBtn.addEventListener('click', submitSoloCode);

        // Chat buttons
        sendChatBtn4v4.addEventListener('click', () => sendMessage('4v4'));
        chatInput4v4.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') sendMessage('4v4');
        });
        sendChatBtn1v1.addEventListener('click', () => sendMessage('1v1'));
        chatInput1v1.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') sendMessage('1v1');
        });

        // Global Enter key listeners for inputs
        usernameInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') passwordInput.focus(); });
        passwordInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') authAction(); });
        answerInput4v4.addEventListener('keypress', (e) => { if (e.key === 'Enter') submitAnswer(); });
        answerInput1v1Player1.addEventListener('keypress', (e) => { if (e.key === 'Enter') submitAnswer(); });
        answerInput1v1Player2.addEventListener('keypress', (e) => { if (e.key === 'Enter') submitAnswer(); }); // For bot's panel
        soloCodeEditor.addEventListener('keypress', (e) => {
            // Allow new lines in textarea, only submit on Ctrl+Enter or similar if desired
            // For now, no auto-submit on Enter for code editor
        });
    });

    // --- Socket.IO Event Listeners (for Global Leaderboard and Chat) ---
    socket.on('connect', () => {
        console.log('Connected to backend Socket.IO server!');
        // Request leaderboard immediately after connection
        socket.emit('request_global_leaderboard');
        // If a user is logged in (client-side), inform the backend for chat/leaderboard purposes
        if (currentUser) {
            socket.emit('player_connected', { username: currentUser.username, elo: currentUser.elo });
        }
    });

    socket.on('disconnect', () => {
        console.log('Disconnected from backend Socket.IO server.');
    });

    // Removed: socket.on('chat message', (msg) => { ... });

    socket.on('global_leaderboard_update', (leaderboardData) => {
        console.log('Global Leaderboard Updated from Server:', leaderboardData);
        // This updates the global leaderboard displayed in the gameModeSelection screen
        // and also within the gameUI's ranking area.
        updateGlobalLeaderboardFromBackend(leaderboardData);
    });

    /**
     * Updates the global leaderboard table using data received from the backend.
     * This is separate from the client-side `updateGlobalLeaderboard` which uses in-memory `users`.
     * This function is specifically for data from the Socket.IO event.
     * @param {Array<Object>} leaderboardData Array of player objects { username, elo }
     */
    function updateGlobalLeaderboardFromBackend(leaderboardData) {
        globalLeaderboardBody.innerHTML = '';
        if (leaderboardData && leaderboardData.length > 0) {
            leaderboardData.forEach((player, index) => {
                const row = globalLeaderboardBody.insertRow();
                // Note: Accuracy is not provided by backend leaderboard, so it will be 0% or N/A
                row.innerHTML = `
                    <td>${index + 1}</td>
                    <td>${player.username}</td>
                    <td>${player.elo}</td>
                    <td>N/A</td>
                `;
            });
        } else {
            const row = globalLeaderboardBody.insertRow();
            const cell = row.insertCell(0);
            cell.colSpan = 4;
            cell.textContent = 'No global leaderboard data available from server.';
            cell.style.textAlign = 'center';
        }
    }

    // Initial check when the page loads
    window.onload = function() {
        // Initial UI state: show auth container
        showSection(authContainer);
        // Request global leaderboard data on load
        socket.emit('request_global_leaderboard');
    };
</script>
</body>
</html>
